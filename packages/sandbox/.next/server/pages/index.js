"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/index";
exports.ids = ["pages/index"];
exports.modules = {

/***/ "./pages/index.tsx":
/*!*************************!*\
  !*** ./pages/index.tsx ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! styled-components */ \"../styled-components/dist/styled-components.cjs.js\");\n/* harmony import */ var _src_Button_example__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/Button.example */ \"./src/Button.example.tsx\");\n\n\n\nconst GlobalStyle = styled_components__WEBPACK_IMPORTED_MODULE_2__.createGlobalStyle`\n  body {\n    font-size: 16px;\n    line-height: 1.2;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n    font-style: normal;\n    padding: 0;\n    margin: 0;\n    color: rgb(46, 68, 78);\n    -webkit-font-smoothing: subpixel-antialiased;\n  }\n\n  * {\n    box-sizing: border-box;\n  }\n`;\nconst Body = styled_components__WEBPACK_IMPORTED_MODULE_2__[\"default\"].main.withConfig({\n    displayName: \"pages__Body\",\n    componentId: \"sc-c31f5124-0\"\n})`\n  width: 100vw;\n  min-width: 100vw;\n  min-height: 100vh;\n\n  background-image: linear-gradient(20deg, #e6356f, #69e7f7);\n\n  padding: 30px 20px;\n`;\nconst Heading = styled_components__WEBPACK_IMPORTED_MODULE_2__[\"default\"].div.withConfig({\n    displayName: \"pages__Heading\",\n    componentId: \"sc-c31f5124-1\"\n})`\n  text-align: center;\n`;\nconst Title = styled_components__WEBPACK_IMPORTED_MODULE_2__[\"default\"].h1.withConfig({\n    displayName: \"pages__Title\",\n    componentId: \"sc-c31f5124-2\"\n})`\n  @media (max-width: 40.625em) {\n    font-size: 26px;\n  }\n`;\nconst Subtitle = styled_components__WEBPACK_IMPORTED_MODULE_2__[\"default\"].p.withConfig({\n    displayName: \"pages__Subtitle\",\n    componentId: \"sc-c31f5124-3\"\n})``;\nconst Content = styled_components__WEBPACK_IMPORTED_MODULE_2__[\"default\"].div.withConfig({\n    displayName: \"pages__Content\",\n    componentId: \"sc-c31f5124-4\"\n})`\n  background: white;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  max-width: 860px;\n\n  margin: 0 auto;\n  margin-top: 60px;\n`;\nconst Code = styled_components__WEBPACK_IMPORTED_MODULE_2__[\"default\"].span.withConfig({\n    displayName: \"pages__Code\",\n    componentId: \"sc-c31f5124-5\"\n})`\n  white-space: pre;\n  vertical-align: middle;\n  font-family: monospace;\n  display: inline-block;\n  background-color: #1e1f27;\n  color: #c5c8c6;\n  padding: 0.1em 0.3em 0.15em;\n  font-size: 0.8em;\n  border-radius: 0.2em;\n`;\nconst App = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Body, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(GlobalStyle, {}, void 0, false, {\n                fileName: \"/Users/b34r/code/styled-components/packages/sandbox/pages/index.tsx\",\n                lineNumber: 69,\n                columnNumber: 5\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Heading, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Title, {\n                        children: [\n                            \"Interactive sandbox for \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Code, {\n                                children: \"styled-components\"\n                            }, void 0, false, {\n                                fileName: \"/Users/b34r/code/styled-components/packages/sandbox/pages/index.tsx\",\n                                lineNumber: 72,\n                                columnNumber: 33\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/b34r/code/styled-components/packages/sandbox/pages/index.tsx\",\n                        lineNumber: 71,\n                        columnNumber: 7\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Subtitle, {\n                        children: [\n                            \"Make changes to the files in \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Code, {\n                                children: \"./src\"\n                            }, void 0, false, {\n                                fileName: \"/Users/b34r/code/styled-components/packages/sandbox/pages/index.tsx\",\n                                lineNumber: 75,\n                                columnNumber: 38\n                            }, undefined),\n                            \" and see them take effect in realtime!\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/b34r/code/styled-components/packages/sandbox/pages/index.tsx\",\n                        lineNumber: 74,\n                        columnNumber: 7\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/b34r/code/styled-components/packages/sandbox/pages/index.tsx\",\n                lineNumber: 70,\n                columnNumber: 5\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Content, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_Button_example__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n                    fileName: \"/Users/b34r/code/styled-components/packages/sandbox/pages/index.tsx\",\n                    lineNumber: 79,\n                    columnNumber: 7\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/b34r/code/styled-components/packages/sandbox/pages/index.tsx\",\n                lineNumber: 78,\n                columnNumber: 5\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/b34r/code/styled-components/packages/sandbox/pages/index.tsx\",\n        lineNumber: 68,\n        columnNumber: 3\n    }, undefined);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUE4RDtBQUNaO0FBRWxELE1BQU1HLGNBQWNGLGdFQUFpQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUFldEMsQ0FBQztBQUVELE1BQU1HLE9BQU9KLHlFQUFXOzs7RUFBQSxDQUFDOzs7Ozs7OztBQVF6QixDQUFDO0FBRUQsTUFBTU0sVUFBVU4sd0VBQVU7OztFQUFBLENBQUM7O0FBRTNCLENBQUM7QUFFRCxNQUFNUSxRQUFRUix1RUFBUzs7O0VBQUEsQ0FBQzs7OztBQUl4QixDQUFDO0FBRUQsTUFBTVUsV0FBV1Ysc0VBQVE7OztFQUFBLENBQUMsQ0FBQztBQUUzQixNQUFNWSxVQUFVWix3RUFBVTs7O0VBQUEsQ0FBQzs7Ozs7Ozs7OztBQVUzQixDQUFDO0FBRUQsTUFBTWEsT0FBT2IseUVBQVc7OztFQUFBLENBQUM7Ozs7Ozs7Ozs7QUFVekIsQ0FBQztBQUVELE1BQU1lLE1BQU0sa0JBQ1YsOERBQUNYOzswQkFDQyw4REFBQ0Q7Ozs7OzBCQUNELDhEQUFDRzs7a0NBQ0MsOERBQUNFOzs0QkFBTTswQ0FDbUIsOERBQUNLOzBDQUFLOzs7Ozs7Ozs7Ozs7a0NBRWhDLDhEQUFDSDs7NEJBQVM7MENBQ3FCLDhEQUFDRzswQ0FBSzs7Ozs7OzRCQUFZOzs7Ozs7Ozs7Ozs7OzBCQUduRCw4REFBQ0Q7MEJBQ0MsNEVBQUNWLDJEQUFhQTs7Ozs7Ozs7Ozs7Ozs7OztBQUtwQixpRUFBZWEsR0FBR0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbmRib3gvLi9wYWdlcy9pbmRleC50c3g/MDdmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkLCB7IGNyZWF0ZUdsb2JhbFN0eWxlIH0gZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xuaW1wb3J0IEJ1dHRvbkV4YW1wbGUgZnJvbSAnLi4vc3JjL0J1dHRvbi5leGFtcGxlJztcblxuY29uc3QgR2xvYmFsU3R5bGUgPSBjcmVhdGVHbG9iYWxTdHlsZWBcbiAgYm9keSB7XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIGxpbmUtaGVpZ2h0OiAxLjI7XG4gICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTZWdvZSBVSVwiLCBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmLCBcIkFwcGxlIENvbG9yIEVtb2ppXCIsIFwiU2Vnb2UgVUkgRW1vamlcIiwgXCJTZWdvZSBVSSBTeW1ib2xcIjtcbiAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDA7XG4gICAgY29sb3I6IHJnYig0NiwgNjgsIDc4KTtcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBzdWJwaXhlbC1hbnRpYWxpYXNlZDtcbiAgfVxuXG4gICoge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIH1cbmA7XG5cbmNvbnN0IEJvZHkgPSBzdHlsZWQubWFpbmBcbiAgd2lkdGg6IDEwMHZ3O1xuICBtaW4td2lkdGg6IDEwMHZ3O1xuICBtaW4taGVpZ2h0OiAxMDB2aDtcblxuICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQoMjBkZWcsICNlNjM1NmYsICM2OWU3ZjcpO1xuXG4gIHBhZGRpbmc6IDMwcHggMjBweDtcbmA7XG5cbmNvbnN0IEhlYWRpbmcgPSBzdHlsZWQuZGl2YFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG5gO1xuXG5jb25zdCBUaXRsZSA9IHN0eWxlZC5oMWBcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDQwLjYyNWVtKSB7XG4gICAgZm9udC1zaXplOiAyNnB4O1xuICB9XG5gO1xuXG5jb25zdCBTdWJ0aXRsZSA9IHN0eWxlZC5wYGA7XG5cbmNvbnN0IENvbnRlbnQgPSBzdHlsZWQuZGl2YFxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIHdpZHRoOiAxMDAlO1xuICBtYXgtd2lkdGg6IDg2MHB4O1xuXG4gIG1hcmdpbjogMCBhdXRvO1xuICBtYXJnaW4tdG9wOiA2MHB4O1xuYDtcblxuY29uc3QgQ29kZSA9IHN0eWxlZC5zcGFuYFxuICB3aGl0ZS1zcGFjZTogcHJlO1xuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIGJhY2tncm91bmQtY29sb3I6ICMxZTFmMjc7XG4gIGNvbG9yOiAjYzVjOGM2O1xuICBwYWRkaW5nOiAwLjFlbSAwLjNlbSAwLjE1ZW07XG4gIGZvbnQtc2l6ZTogMC44ZW07XG4gIGJvcmRlci1yYWRpdXM6IDAuMmVtO1xuYDtcblxuY29uc3QgQXBwID0gKCkgPT4gKFxuICA8Qm9keT5cbiAgICA8R2xvYmFsU3R5bGUgLz5cbiAgICA8SGVhZGluZz5cbiAgICAgIDxUaXRsZT5cbiAgICAgICAgSW50ZXJhY3RpdmUgc2FuZGJveCBmb3IgPENvZGU+c3R5bGVkLWNvbXBvbmVudHM8L0NvZGU+XG4gICAgICA8L1RpdGxlPlxuICAgICAgPFN1YnRpdGxlPlxuICAgICAgICBNYWtlIGNoYW5nZXMgdG8gdGhlIGZpbGVzIGluIDxDb2RlPi4vc3JjPC9Db2RlPiBhbmQgc2VlIHRoZW0gdGFrZSBlZmZlY3QgaW4gcmVhbHRpbWUhXG4gICAgICA8L1N1YnRpdGxlPlxuICAgIDwvSGVhZGluZz5cbiAgICA8Q29udGVudD5cbiAgICAgIDxCdXR0b25FeGFtcGxlIC8+XG4gICAgPC9Db250ZW50PlxuICA8L0JvZHk+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBBcHA7XG4iXSwibmFtZXMiOlsic3R5bGVkIiwiY3JlYXRlR2xvYmFsU3R5bGUiLCJCdXR0b25FeGFtcGxlIiwiR2xvYmFsU3R5bGUiLCJCb2R5IiwibWFpbiIsIkhlYWRpbmciLCJkaXYiLCJUaXRsZSIsImgxIiwiU3VidGl0bGUiLCJwIiwiQ29udGVudCIsIkNvZGUiLCJzcGFuIiwiQXBwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/index.tsx\n");

/***/ }),

/***/ "./src/Button.example.tsx":
/*!********************************!*\
  !*** ./src/Button.example.tsx ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ButtonExample)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-components */ \"../styled-components/dist/styled-components.cjs.js\");\n\n\nconst Button = styled_components__WEBPACK_IMPORTED_MODULE_1__[\"default\"].button.withConfig({\n    displayName: \"Button.example__Button\",\n    componentId: \"sc-713a7e52-0\"\n})`\n  font-size: 16px;\n  border-radius: 5px;\n  padding: 0.25em 1em;\n  margin: 1em 1em;\n  background: transparent;\n  color: palevioletred;\n  border: 2px solid palevioletred;\n  cursor: pointer;\n\n  ${(props)=>props.$primary && styled_components__WEBPACK_IMPORTED_MODULE_1__.css`\n      background: palevioletred;\n      color: white;\n    `};\n`;\nfunction ButtonExample() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Button, {\n                onClick: ()=>alert(\"Clicked!\"),\n                children: \"Normal Button\"\n            }, void 0, false, {\n                fileName: \"/Users/b34r/code/styled-components/packages/sandbox/src/Button.example.tsx\",\n                lineNumber: 24,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Button, {\n                $primary: true,\n                onClick: ()=>alert(\"Clicked!\"),\n                children: \"Primary Button\"\n            }, void 0, false, {\n                fileName: \"/Users/b34r/code/styled-components/packages/sandbox/src/Button.example.tsx\",\n                lineNumber: 25,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQnV0dG9uLmV4YW1wbGUudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUFnRDtBQUVoRCxNQUFNRSxTQUFTRiwyRUFBYTs7O0VBQXdCLENBQUM7Ozs7Ozs7Ozs7RUFVbkQsRUFBRUksQ0FBQUEsUUFDQUEsTUFBTUMsUUFBUSxJQUNkSixrREFBRyxDQUFDOzs7SUFHSixDQUFDLENBQUM7QUFDTixDQUFDO0FBRWMsU0FBU0ssZ0JBQWdCO0lBQ3RDLHFCQUNFOzswQkFDRSw4REFBQ0o7Z0JBQU9LLFNBQVMsSUFBTUMsTUFBTTswQkFBYTs7Ozs7OzBCQUMxQyw4REFBQ047Z0JBQU9HLFFBQVE7Z0JBQUNFLFNBQVMsSUFBTUMsTUFBTTswQkFBYTs7Ozs7Ozs7QUFLekQsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbmRib3gvLi9zcmMvQnV0dG9uLmV4YW1wbGUudHN4P2ZlMjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0eWxlZCwgeyBjc3MgfSBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XG5cbmNvbnN0IEJ1dHRvbiA9IHN0eWxlZC5idXR0b248eyAkcHJpbWFyeT86IGJvb2xlYW4gfT5gXG4gIGZvbnQtc2l6ZTogMTZweDtcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xuICBwYWRkaW5nOiAwLjI1ZW0gMWVtO1xuICBtYXJnaW46IDFlbSAxZW07XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICBjb2xvcjogcGFsZXZpb2xldHJlZDtcbiAgYm9yZGVyOiAycHggc29saWQgcGFsZXZpb2xldHJlZDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICR7cHJvcHMgPT5cbiAgICBwcm9wcy4kcHJpbWFyeSAmJlxuICAgIGNzc2BcbiAgICAgIGJhY2tncm91bmQ6IHBhbGV2aW9sZXRyZWQ7XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgYH07XG5gO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCdXR0b25FeGFtcGxlKCkge1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8QnV0dG9uIG9uQ2xpY2s9eygpID0+IGFsZXJ0KCdDbGlja2VkIScpfT5Ob3JtYWwgQnV0dG9uPC9CdXR0b24+XG4gICAgICA8QnV0dG9uICRwcmltYXJ5IG9uQ2xpY2s9eygpID0+IGFsZXJ0KCdDbGlja2VkIScpfT5cbiAgICAgICAgUHJpbWFyeSBCdXR0b25cbiAgICAgIDwvQnV0dG9uPlxuICAgIDwvPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInN0eWxlZCIsImNzcyIsIkJ1dHRvbiIsImJ1dHRvbiIsInByb3BzIiwiJHByaW1hcnkiLCJCdXR0b25FeGFtcGxlIiwib25DbGljayIsImFsZXJ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Button.example.tsx\n");

/***/ }),

/***/ "../styled-components/dist/styled-components.cjs.js":
/*!**********************************************************!*\
  !*** ../styled-components/dist/styled-components.cjs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\nvar React = __webpack_require__(/*! react */ \"react\");\nvar shallowequal = __webpack_require__(/*! shallowequal */ \"shallowequal\");\nvar stylis = __webpack_require__(/*! stylis */ \"stylis\");\nvar unitless = __webpack_require__(/*! @emotion/unitless */ \"@emotion/unitless\");\n\nfunction _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }\n\nvar React__default = /*#__PURE__*/_interopDefault(React);\nvar shallowequal__default = /*#__PURE__*/_interopDefault(shallowequal);\nvar unitless__default = /*#__PURE__*/_interopDefault(unitless);\n\nvar SC_ATTR = (typeof process !== 'undefined' && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR)) ||\n    'data-styled';\nvar SC_ATTR_ACTIVE = 'active';\nvar SC_ATTR_VERSION = 'data-styled-version';\nvar SC_VERSION = \"6.0.0-beta.8\";\nvar SPLITTER = '/*!sc*/\\n';\nvar IS_BROWSER = typeof undefined !== 'undefined' ;\nvar DISABLE_SPEEDY = Boolean(typeof SC_DISABLE_SPEEDY === 'boolean'\n    ? SC_DISABLE_SPEEDY\n    : typeof process !== 'undefined' &&\n        typeof process.env.REACT_APP_SC_DISABLE_SPEEDY !== 'undefined' &&\n        process.env.REACT_APP_SC_DISABLE_SPEEDY !== ''\n        ? process.env.REACT_APP_SC_DISABLE_SPEEDY === 'false'\n            ? false\n            : process.env.REACT_APP_SC_DISABLE_SPEEDY\n        : typeof process !== 'undefined' &&\n            typeof process.env.SC_DISABLE_SPEEDY !== 'undefined' &&\n            process.env.SC_DISABLE_SPEEDY !== ''\n            ? process.env.SC_DISABLE_SPEEDY === 'false'\n                ? false\n                : process.env.SC_DISABLE_SPEEDY\n            : \"development\" !== 'production');\n// Shared empty execution context when generating static styles\nvar STATIC_EXECUTION_CONTEXT = {};\n\nvar invalidHookCallRe = /invalid hook call/i;\nvar seen = new Set();\nvar checkDynamicCreation = function (displayName, componentId) {\n    if (true) {\n        var parsedIdString = componentId ? \" with the id of \\\"\".concat(componentId, \"\\\"\") : '';\n        var message_1 = \"The component \".concat(displayName).concat(parsedIdString, \" has been created dynamically.\\n\") +\n            \"You may see this warning because you've called styled inside another component.\\n\" +\n            'To resolve this only create new StyledComponents outside of any render method and function component.';\n        // If a hook is called outside of a component:\n        // React 17 and earlier throw an error\n        // React 18 and above use console.error\n        var originalConsoleError_1 = console.error;\n        try {\n            var didNotCallInvalidHook_1 = true;\n            console.error = function (consoleErrorMessage) {\n                var consoleErrorArgs = [];\n                for (var _i = 1; _i < arguments.length; _i++) {\n                    consoleErrorArgs[_i - 1] = arguments[_i];\n                }\n                // The error here is expected, since we're expecting anything that uses `checkDynamicCreation` to\n                // be called outside of a React component.\n                if (invalidHookCallRe.test(consoleErrorMessage)) {\n                    didNotCallInvalidHook_1 = false;\n                    // This shouldn't happen, but resets `warningSeen` if we had this error happen intermittently\n                    seen.delete(message_1);\n                }\n                else {\n                    originalConsoleError_1.apply(void 0, tslib.__spreadArray([consoleErrorMessage], consoleErrorArgs, false));\n                }\n            };\n            // We purposefully call `useRef` outside of a component and expect it to throw\n            // If it doesn't, then we're inside another component.\n            // eslint-disable-next-line react-hooks/rules-of-hooks\n            React.useRef();\n            if (didNotCallInvalidHook_1 && !seen.has(message_1)) {\n                // eslint-disable-next-line no-console\n                console.warn(message_1);\n                seen.add(message_1);\n            }\n        }\n        catch (error) {\n            // The error here is expected, since we're expecting anything that uses `checkDynamicCreation` to\n            // be called outside of a React component.\n            if (invalidHookCallRe.test(error.message)) {\n                // This shouldn't happen, but resets `warningSeen` if we had this error happen intermittently\n                seen.delete(message_1);\n            }\n        }\n        finally {\n            console.error = originalConsoleError_1;\n        }\n    }\n};\n\nvar LIMIT = 200;\nvar createWarnTooManyClasses = (function (displayName, componentId) {\n    var generatedClasses = {};\n    var warningSeen = false;\n    return function (className) {\n        if (!warningSeen) {\n            generatedClasses[className] = true;\n            if (Object.keys(generatedClasses).length >= LIMIT) {\n                // Unable to find latestRule in test environment.\n                /* eslint-disable no-console, prefer-template */\n                var parsedIdString = componentId ? \" with the id of \\\"\".concat(componentId, \"\\\"\") : '';\n                console.warn(\"Over \".concat(LIMIT, \" classes were generated for component \").concat(displayName).concat(parsedIdString, \".\\n\") +\n                    'Consider using the attrs method, together with a style object for frequently changed styles.\\n' +\n                    'Example:\\n' +\n                    '  const Component = styled.div.attrs(props => ({\\n' +\n                    '    style: {\\n' +\n                    '      background: props.background,\\n' +\n                    '    },\\n' +\n                    '  }))`width: 100%;`\\n\\n' +\n                    '  <Component />');\n                warningSeen = true;\n                generatedClasses = {};\n            }\n        }\n    };\n});\n\nvar EMPTY_ARRAY = Object.freeze([]);\nvar EMPTY_OBJECT = Object.freeze({});\n\nfunction determineTheme(props, providedTheme, defaultProps) {\n    if (defaultProps === void 0) { defaultProps = EMPTY_OBJECT; }\n    return (props.theme !== defaultProps.theme && props.theme) || providedTheme || defaultProps.theme;\n}\n\n// Thanks to ReactDOMFactories for this handy list!\nvar domElements = [\n    'a',\n    'abbr',\n    'address',\n    'area',\n    'article',\n    'aside',\n    'audio',\n    'b',\n    'base',\n    'bdi',\n    'bdo',\n    'big',\n    'blockquote',\n    'body',\n    'br',\n    'button',\n    'canvas',\n    'caption',\n    'cite',\n    'code',\n    'col',\n    'colgroup',\n    'data',\n    'datalist',\n    'dd',\n    'del',\n    'details',\n    'dfn',\n    'dialog',\n    'div',\n    'dl',\n    'dt',\n    'em',\n    'embed',\n    'fieldset',\n    'figcaption',\n    'figure',\n    'footer',\n    'form',\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'head',\n    'header',\n    'hgroup',\n    'hr',\n    'html',\n    'i',\n    'iframe',\n    'img',\n    'input',\n    'ins',\n    'kbd',\n    'keygen',\n    'label',\n    'legend',\n    'li',\n    'link',\n    'main',\n    'map',\n    'mark',\n    'menu',\n    'menuitem',\n    'meta',\n    'meter',\n    'nav',\n    'noscript',\n    'object',\n    'ol',\n    'optgroup',\n    'option',\n    'output',\n    'p',\n    'param',\n    'picture',\n    'pre',\n    'progress',\n    'q',\n    'rp',\n    'rt',\n    'ruby',\n    's',\n    'samp',\n    'script',\n    'section',\n    'select',\n    'small',\n    'source',\n    'span',\n    'strong',\n    'style',\n    'sub',\n    'summary',\n    'sup',\n    'table',\n    'tbody',\n    'td',\n    'textarea',\n    'tfoot',\n    'th',\n    'thead',\n    'time',\n    'title',\n    'tr',\n    'track',\n    'u',\n    'ul',\n    'var',\n    'video',\n    'wbr',\n    'circle',\n    'clipPath',\n    'defs',\n    'ellipse',\n    'foreignObject',\n    'g',\n    'image',\n    'line',\n    'linearGradient',\n    'marker',\n    'mask',\n    'path',\n    'pattern',\n    'polygon',\n    'polyline',\n    'radialGradient',\n    'rect',\n    'stop',\n    'svg',\n    'text',\n    'tspan',\n];\n\n// Source: https://www.w3.org/TR/cssom-1/#serialize-an-identifier\n// Control characters and non-letter first symbols are not supported\nvar escapeRegex = /[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^`{|}~-]+/g;\nvar dashesAtEnds = /(^-|-$)/g;\n/**\n * TODO: Explore using CSS.escape when it becomes more available\n * in evergreen browsers.\n */\nfunction escape(str) {\n    return str // Replace all possible CSS selectors\n        .replace(escapeRegex, '-') // Remove extraneous hyphens at the start and end\n        .replace(dashesAtEnds, '');\n}\n\nvar AD_REPLACER_R = /(a)(d)/gi;\n/* This is the \"capacity\" of our alphabet i.e. 2x26 for all letters plus their capitalised\n * counterparts */\nvar charsLength = 52;\n/* start at 75 for 'a' until 'z' (25) and then start at 65 for capitalised letters */\nvar getAlphabeticChar = function (code) { return String.fromCharCode(code + (code > 25 ? 39 : 97)); };\n/* input a number, usually a hash and convert it to base-52 */\nfunction generateAlphabeticName(code) {\n    var name = '';\n    var x;\n    /* get a char and divide by alphabet-length */\n    for (x = Math.abs(code); x > charsLength; x = (x / charsLength) | 0) {\n        name = getAlphabeticChar(x % charsLength) + name;\n    }\n    return (getAlphabeticChar(x % charsLength) + name).replace(AD_REPLACER_R, '$1-$2');\n}\n\nvar SEED$1 = 5381;\n// When we have separate strings it's useful to run a progressive\n// version of djb2 where we pretend that we're still looping over\n// the same string\nvar phash = function (h, x) {\n    var i = x.length;\n    while (i) {\n        h = (h * 33) ^ x.charCodeAt(--i);\n    }\n    return h;\n};\n// This is a djb2 hashing function\nvar hash = function (x) {\n    return phash(SEED$1, x);\n};\n\nfunction generateComponentId(str) {\n    return generateAlphabeticName(hash(str) >>> 0);\n}\n\nfunction getComponentName(target) {\n    return (( true ? typeof target === 'string' && target : 0) ||\n        target.displayName ||\n        target.name ||\n        'Component');\n}\n\nfunction isTag(target) {\n    return (typeof target === 'string' &&\n        ( true\n            ? target.charAt(0) === target.charAt(0).toLowerCase()\n            : 0));\n}\n\nfunction generateDisplayName(target) {\n    return isTag(target) ? \"styled.\".concat(target) : \"Styled(\".concat(getComponentName(target), \")\");\n}\n\nvar _a;\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\n// copied from react-is\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\n/**\n * Adapted from hoist-non-react-statics to avoid the react-is dependency.\n */\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextType: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    getDerivedStateFromError: true,\n    getDerivedStateFromProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true,\n};\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true,\n};\nvar FORWARD_REF_STATICS = {\n    $$typeof: true,\n    render: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true,\n};\nvar MEMO_STATICS = {\n    $$typeof: true,\n    compare: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true,\n    type: true,\n};\nvar TYPE_STATICS = (_a = {},\n    _a[REACT_FORWARD_REF_TYPE] = FORWARD_REF_STATICS,\n    _a[REACT_MEMO_TYPE] = MEMO_STATICS,\n    _a);\n// adapted from react-is\nfunction isMemo(object) {\n    var $$typeofType = 'type' in object && object.type.$$typeof;\n    return $$typeofType === REACT_MEMO_TYPE;\n}\nfunction getStatics(component) {\n    // React v16.11 and below\n    if (isMemo(component)) {\n        return MEMO_STATICS;\n    }\n    // React v16.12 and above\n    return '$$typeof' in component\n        ? TYPE_STATICS[component['$$typeof']]\n        : REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, excludelist) {\n    if (typeof sourceComponent !== 'string') {\n        // don't hoist over string (html) components\n        if (objectPrototype) {\n            var inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent, excludelist);\n            }\n        }\n        var keys = getOwnPropertyNames(sourceComponent);\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n        var targetStatics = getStatics(targetComponent);\n        var sourceStatics = getStatics(sourceComponent);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!(key in KNOWN_STATICS) &&\n                !(excludelist && excludelist[key]) &&\n                !(sourceStatics && key in sourceStatics) &&\n                !(targetStatics && key in targetStatics)) {\n                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try {\n                    // Avoid failures from read-only properties\n                    defineProperty(targetComponent, key, descriptor);\n                }\n                catch (e) {\n                    /* ignore */\n                }\n            }\n        }\n    }\n    return targetComponent;\n}\n\nfunction isStyledComponent(target) {\n    return typeof target === 'object' && 'styledComponentId' in target;\n}\n\n/**\n * Convenience function for joining strings to form className chains\n */\nfunction joinStrings() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.filter(Boolean).join(' ');\n}\n\nfunction isPlainObject(x) {\n    return (x !== null &&\n        typeof x === 'object' &&\n        /* a check for empty prototype would be more typical, but that\n           doesn't play well with objects created in different vm contexts */\n        (!x.constructor || x.constructor.name === 'Object') &&\n        (x.toString ? x.toString() : Object.prototype.toString.call(x)) === '[object Object]' &&\n        /* check for reasonable markers that the object isn't an element for react & preact/compat */\n        !('props' in x && (x.$$typeof || x.constructor === undefined)));\n}\n\nfunction mixinRecursively(target, source, forceMerge) {\n    if (forceMerge === void 0) { forceMerge = false; }\n    /* only merge into POJOs, Arrays, but for top level objects only\n     * allow to merge into anything by passing forceMerge = true */\n    if (!forceMerge && !isPlainObject(target) && !Array.isArray(target)) {\n        return source;\n    }\n    if (Array.isArray(source)) {\n        for (var key = 0; key < source.length; key++) {\n            target[key] = mixinRecursively(target[key], source[key]);\n        }\n    }\n    else if (isPlainObject(source)) {\n        for (var key in source) {\n            target[key] = mixinRecursively(target[key], source[key]);\n        }\n    }\n    return target;\n}\n/**\n * Arrays & POJOs merged recursively, other objects and value types are overridden\n * If target is not a POJO or an Array, it will get source properties injected via shallow merge\n * Source objects applied left to right.  Mutates & returns target.  Similar to lodash merge.\n */\nfunction mixinDeep(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {\n        var source = sources_1[_a];\n        mixinRecursively(target, source, true);\n    }\n    return target;\n}\n\nvar errorMap = {\n    '1': 'Cannot create styled-component for component: %s.\\n\\n',\n    '2': \"Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\\n\\n- Are you trying to reuse it across renders?\\n- Are you accidentally calling collectStyles twice?\\n\\n\",\n    '3': 'Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\\n\\n',\n    '4': 'The `StyleSheetManager` expects a valid target or sheet prop!\\n\\n- Does this error occur on the client and is your target falsy?\\n- Does this error occur on the server and is the sheet falsy?\\n\\n',\n    '5': 'The clone method cannot be used on the client!\\n\\n- Are you running in a client-like environment on the server?\\n- Are you trying to run SSR on the client?\\n\\n',\n    '6': \"Trying to insert a new style tag, but the given Node is unmounted!\\n\\n- Are you using a custom target that isn't mounted?\\n- Does your document not have a valid head element?\\n- Have you accidentally removed a style tag manually?\\n\\n\",\n    '7': 'ThemeProvider: Please return an object from your \"theme\" prop function, e.g.\\n\\n```js\\ntheme={() => ({})}\\n```\\n\\n',\n    '8': 'ThemeProvider: Please make your \"theme\" prop an object.\\n\\n',\n    '9': 'Missing document `<head>`\\n\\n',\n    '10': 'Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\\n\\n',\n    '11': '_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\\n\\n',\n    '12': 'It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\\\`\\\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\\n\\n',\n    '13': '%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\\n\\n',\n    '14': 'ThemeProvider: \"theme\" prop is required.\\n\\n',\n    '15': \"A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\\n\\n```js\\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\\n```\\n\\n\",\n    '16': \"Reached the limit of how many styled components may be created at group %s.\\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\\nas for instance in your render method then you may be running into this limitation.\\n\\n\",\n    '17': \"CSSStyleSheet could not be found on HTMLStyleElement.\\nHas styled-components' style tag been unmounted or altered by another script?\\n\",\n};\n\nvar ERRORS =  true ? errorMap : 0;\n/**\n * super basic version of sprintf\n */\nfunction format() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var a = args[0];\n    var b = [];\n    for (var c = 1, len = args.length; c < len; c += 1) {\n        b.push(args[c]);\n    }\n    b.forEach(function (d) {\n        a = a.replace(/%[a-z]/, d);\n    });\n    return a;\n}\n/**\n * Create an error file out of errors.md for development and a simple web link to the full errors\n * in production mode.\n */\nfunction throwStyledComponentsError(code) {\n    var interpolations = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        interpolations[_i - 1] = arguments[_i];\n    }\n    if (false) {}\n    else {\n        return new Error(format.apply(void 0, tslib.__spreadArray([ERRORS[code]], interpolations, false)).trim());\n    }\n}\n\n/** Create a GroupedTag with an underlying Tag implementation */\nvar makeGroupedTag = function (tag) {\n    return new DefaultGroupedTag(tag);\n};\nvar BASE_SIZE = 1 << 9;\nvar DefaultGroupedTag = /** @class */ (function () {\n    function DefaultGroupedTag(tag) {\n        this.groupSizes = new Uint32Array(BASE_SIZE);\n        this.length = BASE_SIZE;\n        this.tag = tag;\n    }\n    DefaultGroupedTag.prototype.indexOfGroup = function (group) {\n        var index = 0;\n        for (var i = 0; i < group; i++) {\n            index += this.groupSizes[i];\n        }\n        return index;\n    };\n    DefaultGroupedTag.prototype.insertRules = function (group, rules) {\n        if (group >= this.groupSizes.length) {\n            var oldBuffer = this.groupSizes;\n            var oldSize = oldBuffer.length;\n            var newSize = oldSize;\n            while (group >= newSize) {\n                newSize <<= 1;\n                if (newSize < 0) {\n                    throw throwStyledComponentsError(16, \"\".concat(group));\n                }\n            }\n            this.groupSizes = new Uint32Array(newSize);\n            this.groupSizes.set(oldBuffer);\n            this.length = newSize;\n            for (var i = oldSize; i < newSize; i++) {\n                this.groupSizes[i] = 0;\n            }\n        }\n        var ruleIndex = this.indexOfGroup(group + 1);\n        if (Array.isArray(rules)) {\n            for (var i = 0, l = rules.length; i < l; i++) {\n                if (this.tag.insertRule(ruleIndex, rules[i])) {\n                    this.groupSizes[group]++;\n                    ruleIndex++;\n                }\n            }\n        }\n        else {\n            if (this.tag.insertRule(ruleIndex, rules)) {\n                this.groupSizes[group]++;\n            }\n        }\n    };\n    DefaultGroupedTag.prototype.clearGroup = function (group) {\n        if (group < this.length) {\n            var length_1 = this.groupSizes[group];\n            var startIndex = this.indexOfGroup(group);\n            var endIndex = startIndex + length_1;\n            this.groupSizes[group] = 0;\n            for (var i = startIndex; i < endIndex; i++) {\n                this.tag.deleteRule(startIndex);\n            }\n        }\n    };\n    DefaultGroupedTag.prototype.getGroup = function (group) {\n        var css = '';\n        if (group >= this.length || this.groupSizes[group] === 0) {\n            return css;\n        }\n        var length = this.groupSizes[group];\n        var startIndex = this.indexOfGroup(group);\n        var endIndex = startIndex + length;\n        for (var i = startIndex; i < endIndex; i++) {\n            css += \"\".concat(this.tag.getRule(i)).concat(SPLITTER);\n        }\n        return css;\n    };\n    return DefaultGroupedTag;\n}());\n\nvar MAX_SMI = 1 << (31 - 1);\nvar groupIDRegister = new Map();\nvar reverseRegister = new Map();\nvar nextFreeGroup = 1;\nvar getGroupForId = function (id) {\n    if (groupIDRegister.has(id)) {\n        return groupIDRegister.get(id);\n    }\n    while (reverseRegister.has(nextFreeGroup)) {\n        nextFreeGroup++;\n    }\n    var group = nextFreeGroup++;\n    if ( true && ((group | 0) < 0 || group > MAX_SMI)) {\n        throw throwStyledComponentsError(16, \"\".concat(group));\n    }\n    groupIDRegister.set(id, group);\n    reverseRegister.set(group, id);\n    return group;\n};\nvar getIdForGroup = function (group) {\n    return reverseRegister.get(group);\n};\nvar setGroupForId = function (id, group) {\n    groupIDRegister.set(id, group);\n    reverseRegister.set(group, id);\n};\n\nvar SELECTOR = \"style[\".concat(SC_ATTR, \"][\").concat(SC_ATTR_VERSION, \"=\\\"\").concat(SC_VERSION, \"\\\"]\");\nvar MARKER_RE = new RegExp(\"^\".concat(SC_ATTR, \"\\\\.g(\\\\d+)\\\\[id=\\\"([\\\\w\\\\d-]+)\\\"\\\\].*?\\\"([^\\\"]*)\"));\nvar outputSheet = function (sheet) {\n    var tag = sheet.getTag();\n    var length = tag.length;\n    var css = '';\n    var _loop_1 = function (group) {\n        var id = getIdForGroup(group);\n        if (id === undefined)\n            return \"continue\";\n        var names = sheet.names.get(id);\n        var rules = tag.getGroup(group);\n        if (names === undefined || rules.length === 0)\n            return \"continue\";\n        var selector = \"\".concat(SC_ATTR, \".g\").concat(group, \"[id=\\\"\").concat(id, \"\\\"]\");\n        var content = '';\n        if (names !== undefined) {\n            names.forEach(function (name) {\n                if (name.length > 0) {\n                    content += \"\".concat(name, \",\");\n                }\n            });\n        }\n        // NOTE: It's easier to collect rules and have the marker\n        // after the actual rules to simplify the rehydration\n        css += \"\".concat(rules).concat(selector, \"{content:\\\"\").concat(content, \"\\\"}\").concat(SPLITTER);\n    };\n    for (var group = 0; group < length; group++) {\n        _loop_1(group);\n    }\n    return css;\n};\nvar rehydrateNamesFromContent = function (sheet, id, content) {\n    var names = content.split(',');\n    var name;\n    for (var i = 0, l = names.length; i < l; i++) {\n        // eslint-disable-next-line\n        if ((name = names[i])) {\n            sheet.registerName(id, name);\n        }\n    }\n};\nvar rehydrateSheetFromTag = function (sheet, style) {\n    var _a;\n    var parts = ((_a = style.textContent) !== null && _a !== void 0 ? _a : '').split(SPLITTER);\n    var rules = [];\n    for (var i = 0, l = parts.length; i < l; i++) {\n        var part = parts[i].trim();\n        if (!part)\n            continue;\n        var marker = part.match(MARKER_RE);\n        if (marker) {\n            var group = parseInt(marker[1], 10) | 0;\n            var id = marker[2];\n            if (group !== 0) {\n                // Rehydrate componentId to group index mapping\n                setGroupForId(id, group);\n                // Rehydrate names and rules\n                // looks like: data-styled.g11[id=\"idA\"]{content:\"nameA,\"}\n                rehydrateNamesFromContent(sheet, id, marker[3]);\n                sheet.getTag().insertRules(group, rules);\n            }\n            rules.length = 0;\n        }\n        else {\n            rules.push(part);\n        }\n    }\n};\nvar rehydrateSheet = function (sheet) {\n    var nodes = document.querySelectorAll(SELECTOR);\n    for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n        if (node && node.getAttribute(SC_ATTR) !== SC_ATTR_ACTIVE) {\n            rehydrateSheetFromTag(sheet, node);\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        }\n    }\n};\n\nfunction getNonce() {\n    return  true ? __webpack_require__.nc : 0;\n}\n\nvar ELEMENT_TYPE = 1;\n/* Node.ELEMENT_TYPE */\n/** Find last style element if any inside target */\nvar findLastStyleTag = function (target) {\n    var childNodes = target.childNodes;\n    for (var i = childNodes.length; i >= 0; i--) {\n        var child = childNodes[i];\n        if (child && child.nodeType === ELEMENT_TYPE && child.hasAttribute(SC_ATTR)) {\n            return child;\n        }\n    }\n    return undefined;\n};\n/** Create a style element inside `target` or <head> after the last */\nvar makeStyleTag = function (target) {\n    var head = document.head;\n    var parent = target || head;\n    var style = document.createElement('style');\n    var prevStyle = findLastStyleTag(parent);\n    var nextSibling = prevStyle !== undefined ? prevStyle.nextSibling : null;\n    style.setAttribute(SC_ATTR, SC_ATTR_ACTIVE);\n    style.setAttribute(SC_ATTR_VERSION, SC_VERSION);\n    var nonce = getNonce();\n    if (nonce)\n        style.setAttribute('nonce', nonce);\n    parent.insertBefore(style, nextSibling);\n    return style;\n};\n/** Get the CSSStyleSheet instance for a given style element */\nvar getSheet = function (tag) {\n    if (tag.sheet) {\n        return tag.sheet;\n    }\n    // Avoid Firefox quirk where the style element might not have a sheet property\n    var styleSheets = document.styleSheets;\n    for (var i = 0, l = styleSheets.length; i < l; i++) {\n        var sheet = styleSheets[i];\n        if (sheet.ownerNode === tag) {\n            return sheet;\n        }\n    }\n    throw throwStyledComponentsError(17);\n};\n\n/** Create a CSSStyleSheet-like tag depending on the environment */\nvar makeTag = function (_a) {\n    var isServer = _a.isServer, useCSSOMInjection = _a.useCSSOMInjection, target = _a.target;\n    if (isServer) {\n        return new VirtualTag(target);\n    }\n    else if (useCSSOMInjection) {\n        return new CSSOMTag(target);\n    }\n    else {\n        return new TextTag(target);\n    }\n};\nvar CSSOMTag = /** @class */ (function () {\n    function CSSOMTag(target) {\n        var element = (this.element = makeStyleTag(target));\n        // Avoid Edge bug where empty style elements don't create sheets\n        element.appendChild(document.createTextNode(''));\n        this.sheet = getSheet(element);\n        this.length = 0;\n    }\n    CSSOMTag.prototype.insertRule = function (index, rule) {\n        try {\n            this.sheet.insertRule(rule, index);\n            this.length++;\n            return true;\n        }\n        catch (_error) {\n            return false;\n        }\n    };\n    CSSOMTag.prototype.deleteRule = function (index) {\n        this.sheet.deleteRule(index);\n        this.length--;\n    };\n    CSSOMTag.prototype.getRule = function (index) {\n        var rule = this.sheet.cssRules[index];\n        // Avoid IE11 quirk where cssText is inaccessible on some invalid rules\n        if (rule !== undefined && typeof rule.cssText === 'string') {\n            return rule.cssText;\n        }\n        else {\n            return '';\n        }\n    };\n    return CSSOMTag;\n}());\n/** A Tag that emulates the CSSStyleSheet API but uses text nodes */\nvar TextTag = /** @class */ (function () {\n    function TextTag(target) {\n        var element = (this.element = makeStyleTag(target));\n        this.nodes = element.childNodes;\n        this.length = 0;\n    }\n    TextTag.prototype.insertRule = function (index, rule) {\n        if (index <= this.length && index >= 0) {\n            var node = document.createTextNode(rule);\n            var refNode = this.nodes[index];\n            this.element.insertBefore(node, refNode || null);\n            this.length++;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    TextTag.prototype.deleteRule = function (index) {\n        this.element.removeChild(this.nodes[index]);\n        this.length--;\n    };\n    TextTag.prototype.getRule = function (index) {\n        if (index < this.length) {\n            return this.nodes[index].textContent;\n        }\n        else {\n            return '';\n        }\n    };\n    return TextTag;\n}());\n/** A completely virtual (server-side) Tag that doesn't manipulate the DOM */\nvar VirtualTag = /** @class */ (function () {\n    function VirtualTag(_target) {\n        this.rules = [];\n        this.length = 0;\n    }\n    VirtualTag.prototype.insertRule = function (index, rule) {\n        if (index <= this.length) {\n            this.rules.splice(index, 0, rule);\n            this.length++;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    VirtualTag.prototype.deleteRule = function (index) {\n        this.rules.splice(index, 1);\n        this.length--;\n    };\n    VirtualTag.prototype.getRule = function (index) {\n        if (index < this.length) {\n            return this.rules[index];\n        }\n        else {\n            return '';\n        }\n    };\n    return VirtualTag;\n}());\n\nvar SHOULD_REHYDRATE = IS_BROWSER;\nvar defaultOptions = {\n    isServer: !IS_BROWSER,\n    useCSSOMInjection: !DISABLE_SPEEDY,\n};\n/** Contains the main stylesheet logic for stringification and caching */\nvar StyleSheet = /** @class */ (function () {\n    function StyleSheet(options, globalStyles, names) {\n        if (options === void 0) { options = EMPTY_OBJECT; }\n        if (globalStyles === void 0) { globalStyles = {}; }\n        this.options = tslib.__assign(tslib.__assign({}, defaultOptions), options);\n        this.gs = globalStyles;\n        this.names = new Map(names);\n        this.server = !!options.isServer;\n        // We rehydrate only once and use the sheet that is created first\n        if (!this.server && IS_BROWSER && SHOULD_REHYDRATE) {\n            SHOULD_REHYDRATE = false;\n            rehydrateSheet(this);\n        }\n    }\n    /** Register a group ID to give it an index */\n    StyleSheet.registerId = function (id) {\n        return getGroupForId(id);\n    };\n    StyleSheet.prototype.reconstructWithOptions = function (options, withNames) {\n        if (withNames === void 0) { withNames = true; }\n        return new StyleSheet(tslib.__assign(tslib.__assign({}, this.options), options), this.gs, (withNames && this.names) || undefined);\n    };\n    StyleSheet.prototype.allocateGSInstance = function (id) {\n        return (this.gs[id] = (this.gs[id] || 0) + 1);\n    };\n    /** Lazily initialises a GroupedTag for when it's actually needed */\n    StyleSheet.prototype.getTag = function () {\n        return this.tag || (this.tag = makeGroupedTag(makeTag(this.options)));\n    };\n    /** Check whether a name is known for caching */\n    StyleSheet.prototype.hasNameForId = function (id, name) {\n        return this.names.has(id) && this.names.get(id).has(name);\n    };\n    /** Mark a group's name as known for caching */\n    StyleSheet.prototype.registerName = function (id, name) {\n        getGroupForId(id);\n        if (!this.names.has(id)) {\n            var groupNames = new Set();\n            groupNames.add(name);\n            this.names.set(id, groupNames);\n        }\n        else {\n            this.names.get(id).add(name);\n        }\n    };\n    /** Insert new rules which also marks the name as known */\n    StyleSheet.prototype.insertRules = function (id, name, rules) {\n        this.registerName(id, name);\n        this.getTag().insertRules(getGroupForId(id), rules);\n    };\n    /** Clears all cached names for a given group ID */\n    StyleSheet.prototype.clearNames = function (id) {\n        if (this.names.has(id)) {\n            this.names.get(id).clear();\n        }\n    };\n    /** Clears all rules for a given group ID */\n    StyleSheet.prototype.clearRules = function (id) {\n        this.getTag().clearGroup(getGroupForId(id));\n        this.clearNames(id);\n    };\n    /** Clears the entire tag which deletes all rules but not its names */\n    StyleSheet.prototype.clearTag = function () {\n        // NOTE: This does not clear the names, since it's only used during SSR\n        // so that we can continuously output only new rules\n        this.tag = undefined;\n    };\n    /** Outputs the current sheet as a CSS string with markers for SSR */\n    StyleSheet.prototype.toString = function () {\n        return outputSheet(this);\n    };\n    return StyleSheet;\n}());\n\nvar COMMENT_REGEX = /^\\s*\\/\\/.*$/gm;\nvar COMPLEX_SELECTOR_PREFIX = [':', '[', '.', '#'];\n/**\n * Serialize stylis output as an array of css strings. It is important that rules are\n * separated when using CSSOM injection.\n */\nfunction serialize(children, callback) {\n    return children.map(function (c, i) { return callback(c, i, children, callback); }).filter(Boolean);\n}\nfunction createStylisInstance(_a) {\n    var _b = _a === void 0 ? EMPTY_OBJECT : _a, _c = _b.options, options = _c === void 0 ? EMPTY_OBJECT : _c, _d = _b.plugins, plugins = _d === void 0 ? EMPTY_ARRAY : _d;\n    var _componentId;\n    var _selector;\n    var _selectorRegexp;\n    var _consecutiveSelfRefRegExp;\n    var selfReferenceReplacer = function (match, offset, string) {\n        if (\n        // do not replace the first occurrence if it is complex (has a modifier)\n        (offset === 0 ? !COMPLEX_SELECTOR_PREFIX.includes(string[_selector.length]) : true) && // no consecutive self refs (.b.b); that is a precedence boost and treated differently\n            !string.match(_consecutiveSelfRefRegExp)) {\n            return \".\".concat(_componentId);\n        }\n        return match;\n    };\n    /**\n     * When writing a style like\n     *\n     * & + & {\n     *   color: red;\n     * }\n     *\n     * The second ampersand should be a reference to the static component class. stylis\n     * has no knowledge of static class so we have to intelligently replace the base selector.\n     *\n     * https://github.com/thysultan/stylis.js/tree/v4.0.2#abstract-syntax-structure\n     */\n    var selfReferenceReplacementPlugin = function (element) {\n        if (element.type === stylis.RULESET && element.value.includes('&')) {\n            var props = element.props;\n            props[0] = props[0].replace(_selectorRegexp, selfReferenceReplacer);\n        }\n    };\n    var stringifyRules = function (css, selector, \n    /**\n     * This \"prefix\" referes to a _selector_ prefix.\n     */\n    prefix, componentId) {\n        if (selector === void 0) { selector = ''; }\n        if (prefix === void 0) { prefix = ''; }\n        if (componentId === void 0) { componentId = '&'; }\n        var flatCSS = css.replace(COMMENT_REGEX, '');\n        // stylis has no concept of state to be passed to plugins\n        // but since JS is single-threaded, we can rely on that to ensure\n        // these properties stay in sync with the current stylis run\n        _componentId = componentId;\n        _selector = selector;\n        _selectorRegexp = new RegExp(\"\\\\\".concat(_selector, \"\\\\b\"), 'g');\n        _consecutiveSelfRefRegExp = new RegExp(\"(\\\\\".concat(_selector, \"\\\\b){2,}\"));\n        var middlewares = plugins.slice();\n        /**\n         * Enables automatic vendor-prefixing for styles.\n         */\n        if (options.prefix || options.prefix === undefined) {\n            middlewares.unshift(stylis.prefixer);\n        }\n        middlewares.push(selfReferenceReplacementPlugin, stylis.stringify);\n        return serialize(stylis.compile(options.namespace || prefix || selector\n            ? \"\".concat(options.namespace ? options.namespace + ' ' : '').concat(prefix, \" \").concat(selector, \" { \").concat(flatCSS, \" }\")\n            : flatCSS), stylis.middleware(middlewares));\n    };\n    stringifyRules.hash = plugins.length\n        ? plugins\n            .reduce(function (acc, plugin) {\n            if (!plugin.name) {\n                throwStyledComponentsError(15);\n            }\n            return phash(acc, plugin.name);\n        }, SEED$1)\n            .toString()\n        : '';\n    return stringifyRules;\n}\n\nvar StyleSheetContext = React__default.default.createContext(undefined);\nvar StyleSheetConsumer = StyleSheetContext.Consumer;\nvar StylisContext = React__default.default.createContext(undefined);\nStylisContext.Consumer;\nvar mainSheet = new StyleSheet();\nvar mainStylis = createStylisInstance();\nfunction useStyleSheet() {\n    return React.useContext(StyleSheetContext) || mainSheet;\n}\nfunction useStylis() {\n    return React.useContext(StylisContext) || mainStylis;\n}\nfunction StyleSheetManager(props) {\n    var _a = React.useState(props.stylisPlugins), plugins = _a[0], setPlugins = _a[1];\n    var contextStyleSheet = useStyleSheet();\n    var styleSheet = React.useMemo(function () {\n        var sheet = contextStyleSheet;\n        if (props.sheet) {\n            // eslint-disable-next-line prefer-destructuring\n            sheet = props.sheet;\n        }\n        else if (props.target) {\n            sheet = sheet.reconstructWithOptions({ target: props.target }, false);\n        }\n        if (props.disableCSSOMInjection) {\n            sheet = sheet.reconstructWithOptions({ useCSSOMInjection: false });\n        }\n        return sheet;\n    }, [props.disableCSSOMInjection, props.sheet, props.target]);\n    var stylis = React.useMemo(function () {\n        return createStylisInstance({\n            options: { namespace: props.namespace, prefix: !props.disableVendorPrefixes },\n            plugins: plugins,\n        });\n    }, [props.disableVendorPrefixes, props.namespace, plugins]);\n    React.useEffect(function () {\n        if (!shallowequal__default.default(plugins, props.stylisPlugins))\n            setPlugins(props.stylisPlugins);\n    }, [props.stylisPlugins]);\n    return (React__default.default.createElement(StyleSheetContext.Provider, { value: styleSheet },\n        React__default.default.createElement(StylisContext.Provider, { value: stylis },  true\n            ? React__default.default.Children.only(props.children)\n            : 0)));\n}\n\nvar Keyframes = /** @class */ (function () {\n    function Keyframes(name, rules) {\n        var _this = this;\n        this.inject = function (styleSheet, stylisInstance) {\n            if (stylisInstance === void 0) { stylisInstance = mainStylis; }\n            var resolvedName = _this.name + stylisInstance.hash;\n            if (!styleSheet.hasNameForId(_this.id, resolvedName)) {\n                styleSheet.insertRules(_this.id, resolvedName, stylisInstance(_this.rules, resolvedName, '@keyframes'));\n            }\n        };\n        this.toString = function () {\n            throw throwStyledComponentsError(12, String(_this.name));\n        };\n        this.name = name;\n        this.id = \"sc-keyframes-\".concat(name);\n        this.rules = rules;\n    }\n    Keyframes.prototype.getName = function (stylisInstance) {\n        if (stylisInstance === void 0) { stylisInstance = mainStylis; }\n        return this.name + stylisInstance.hash;\n    };\n    return Keyframes;\n}());\n\n// Taken from https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/shared/dangerousStyleValue.js\nfunction addUnitIfNeeded(name, value) {\n    // https://github.com/amilajack/eslint-plugin-flowtype-errors/issues/133\n    if (value == null || typeof value === 'boolean' || value === '') {\n        return '';\n    }\n    if (typeof value === 'number' && value !== 0 && !(name in unitless__default.default)) {\n        return \"\".concat(value, \"px\"); // Presumes implicit 'px' suffix for unitless numbers\n    }\n    return String(value).trim();\n}\n\n/**\n * inlined version of\n * https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/hyphenateStyleName.js\n */\nvar uppercaseCheck = /[A-Z]/;\nvar uppercasePattern = /[A-Z]/g;\nvar msPattern = /^ms-/;\nvar prefixAndLowerCase = function (char) { return \"-\".concat(char.toLowerCase()); };\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */\nfunction hyphenateStyleName(string) {\n    return uppercaseCheck.test(string) && !string.startsWith('--')\n        ? string.replace(uppercasePattern, prefixAndLowerCase).replace(msPattern, '-ms-')\n        : string;\n}\n\nfunction isFunction(test) {\n    return typeof test === 'function';\n}\n\nfunction isStatelessFunction(test) {\n    return typeof test === 'function' && !(test.prototype && test.prototype.isReactComponent);\n}\n\n/**\n * It's falsish not falsy because 0 is allowed.\n */\nvar isFalsish = function (chunk) {\n    return chunk === undefined || chunk === null || chunk === false || chunk === '';\n};\nvar objToCssArray = function (obj, prevKey) {\n    var rules = [];\n    for (var key in obj) {\n        if (!obj.hasOwnProperty(key) || isFalsish(obj[key]))\n            continue;\n        if ((Array.isArray(obj[key]) && obj[key].isCss) || isFunction(obj[key])) {\n            rules.push(\"\".concat(hyphenateStyleName(key), \":\"), obj[key], ';');\n        }\n        else if (isPlainObject(obj[key])) {\n            rules.push.apply(rules, objToCssArray(obj[key], key));\n        }\n        else {\n            rules.push(\"\".concat(hyphenateStyleName(key), \": \").concat(addUnitIfNeeded(key, obj[key]), \";\"));\n        }\n    }\n    return prevKey ? tslib.__spreadArray(tslib.__spreadArray([\"\".concat(prevKey, \" {\")], rules, true), ['}'], false) : rules;\n};\nfunction flatten(chunk, executionContext, styleSheet, stylisInstance) {\n    if (Array.isArray(chunk)) {\n        var ruleSet = [];\n        for (var i = 0, len = chunk.length, result = void 0; i < len; i += 1) {\n            result = flatten(chunk[i], executionContext, styleSheet, stylisInstance);\n            if (result.length === 0)\n                continue;\n            ruleSet.push.apply(ruleSet, result);\n        }\n        return ruleSet;\n    }\n    if (isFalsish(chunk)) {\n        return [];\n    }\n    /* Handle other components */\n    if (isStyledComponent(chunk)) {\n        return [\".\".concat(chunk.styledComponentId)];\n    }\n    /* Either execute or defer the function */\n    if (isFunction(chunk)) {\n        if (isStatelessFunction(chunk) && executionContext) {\n            var chunkFn = chunk;\n            var result = chunkFn(executionContext);\n            if ( true &&\n                typeof result === 'object' &&\n                !Array.isArray(result) &&\n                !(result instanceof Keyframes) &&\n                !isPlainObject(result)) {\n                // eslint-disable-next-line no-console\n                console.error(\"\".concat(getComponentName(chunkFn), \" is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\"));\n            }\n            return flatten(result, executionContext, styleSheet, stylisInstance);\n        }\n        else {\n            return [chunk];\n        }\n    }\n    if (chunk instanceof Keyframes) {\n        if (styleSheet) {\n            chunk.inject(styleSheet, stylisInstance);\n            return [chunk.getName(stylisInstance)];\n        }\n        else {\n            return [chunk];\n        }\n    }\n    /* Handle objects */\n    return isPlainObject(chunk) ? objToCssArray(chunk) : [chunk.toString()];\n}\n\nfunction isStaticRules(rules) {\n    for (var i = 0; i < rules.length; i += 1) {\n        var rule = rules[i];\n        if (isFunction(rule) && !isStyledComponent(rule)) {\n            // functions are allowed to be static if they're just being\n            // used to get the classname of a nested styled component\n            return false;\n        }\n    }\n    return true;\n}\n\nvar SEED = hash(SC_VERSION);\n/**\n * ComponentStyle is all the CSS-specific stuff, not the React-specific stuff.\n */\nvar ComponentStyle = /** @class */ (function () {\n    function ComponentStyle(rules, componentId, baseStyle) {\n        this.names = [];\n        this.rules = rules;\n        this.staticRulesId = '';\n        this.isStatic =\n             false &&\n                0;\n        this.componentId = componentId;\n        // SC_VERSION gives us isolation between multiple runtimes on the page at once\n        // this is improved further with use of the babel plugin \"namespace\" feature\n        this.baseHash = phash(SEED, componentId);\n        this.baseStyle = baseStyle;\n        // NOTE: This registers the componentId, which ensures a consistent order\n        // for this component's styles compared to others\n        StyleSheet.registerId(componentId);\n    }\n    /*\n     * Flattens a rule set into valid CSS\n     * Hashes it, wraps the whole chunk in a .hash1234 {}\n     * Returns the hash to be injected on render()\n     * */\n    ComponentStyle.prototype.generateAndInjectStyles = function (executionContext, styleSheet, stylis) {\n        var componentId = this.componentId;\n        this.names.length = 0;\n        if (this.baseStyle) {\n            this.names.push(this.baseStyle.generateAndInjectStyles(executionContext, styleSheet, stylis));\n        }\n        // force dynamic classnames if user-supplied stylis plugins are in use\n        if (this.isStatic && !stylis.hash) {\n            if (this.staticRulesId && styleSheet.hasNameForId(componentId, this.staticRulesId)) {\n                this.names.push(this.staticRulesId);\n            }\n            else {\n                var cssStatic = flatten(this.rules, executionContext, styleSheet, stylis).join('');\n                var name_1 = generateAlphabeticName(phash(this.baseHash, cssStatic) >>> 0);\n                if (!styleSheet.hasNameForId(componentId, name_1)) {\n                    var cssStaticFormatted = stylis(cssStatic, \".\".concat(name_1), undefined, componentId);\n                    styleSheet.insertRules(componentId, name_1, cssStaticFormatted);\n                }\n                this.names.push(name_1);\n                this.staticRulesId = name_1;\n            }\n        }\n        else {\n            var length_1 = this.rules.length;\n            var dynamicHash = phash(this.baseHash, stylis.hash);\n            var css = '';\n            for (var i = 0; i < length_1; i++) {\n                var partRule = this.rules[i];\n                if (typeof partRule === 'string') {\n                    css += partRule;\n                    if (true)\n                        dynamicHash = phash(dynamicHash, partRule);\n                }\n                else if (partRule) {\n                    var partChunk = flatten(partRule, executionContext, styleSheet, stylis);\n                    var partString = Array.isArray(partChunk) ? partChunk.join('') : partChunk;\n                    dynamicHash = phash(dynamicHash, partString);\n                    css += partString;\n                }\n            }\n            if (css) {\n                var name_2 = generateAlphabeticName(dynamicHash >>> 0);\n                if (!styleSheet.hasNameForId(componentId, name_2)) {\n                    var cssFormatted = stylis(css, \".\".concat(name_2), undefined, componentId);\n                    styleSheet.insertRules(componentId, name_2, cssFormatted);\n                }\n                this.names.push(name_2);\n            }\n        }\n        return this.names.join(' ');\n    };\n    return ComponentStyle;\n}());\n\nvar ThemeContext = React__default.default.createContext(undefined);\nvar ThemeConsumer = ThemeContext.Consumer;\nfunction mergeTheme(theme, outerTheme) {\n    if (!theme) {\n        throw throwStyledComponentsError(14);\n    }\n    if (isFunction(theme)) {\n        var themeFn = theme;\n        var mergedTheme = themeFn(outerTheme);\n        if ( true &&\n            (mergedTheme === null || Array.isArray(mergedTheme) || typeof mergedTheme !== 'object')) {\n            throw throwStyledComponentsError(7);\n        }\n        return mergedTheme;\n    }\n    if (Array.isArray(theme) || typeof theme !== 'object') {\n        throw throwStyledComponentsError(8);\n    }\n    return outerTheme ? tslib.__assign(tslib.__assign({}, outerTheme), theme) : theme;\n}\n/**\n * Provide a theme to an entire react component tree via context\n */\nfunction ThemeProvider(props) {\n    var outerTheme = React.useContext(ThemeContext);\n    var themeContext = React.useMemo(function () { return mergeTheme(props.theme, outerTheme); }, [props.theme, outerTheme]);\n    if (!props.children) {\n        return null;\n    }\n    return React__default.default.createElement(ThemeContext.Provider, { value: themeContext }, props.children);\n}\n\nvar identifiers = {};\n/* We depend on components having unique IDs */\nfunction generateId(displayName, parentComponentId) {\n    var name = typeof displayName !== 'string' ? 'sc' : escape(displayName);\n    // Ensure that no displayName can lead to duplicate componentIds\n    identifiers[name] = (identifiers[name] || 0) + 1;\n    var componentId = \"\".concat(name, \"-\").concat(generateComponentId(\n    // SC_VERSION gives us isolation between multiple runtimes on the page at once\n    // this is improved further with use of the babel plugin \"namespace\" feature\n    SC_VERSION + name + identifiers[name]));\n    return parentComponentId ? \"\".concat(parentComponentId, \"-\").concat(componentId) : componentId;\n}\nfunction useInjectedStyle(componentStyle, isStatic, resolvedAttrs, warnTooManyClasses) {\n    var styleSheet = useStyleSheet();\n    var stylis = useStylis();\n    var className = componentStyle.generateAndInjectStyles(isStatic ? EMPTY_OBJECT : resolvedAttrs, styleSheet, stylis);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    if (true)\n        React.useDebugValue(className);\n    if ( true && !isStatic && warnTooManyClasses) {\n        warnTooManyClasses(className);\n    }\n    return className;\n}\nfunction useStyledComponentImpl(forwardedComponent, props, forwardedRef, isStatic) {\n    var componentAttrs = forwardedComponent.attrs, componentStyle = forwardedComponent.componentStyle, defaultProps = forwardedComponent.defaultProps, foldedComponentIds = forwardedComponent.foldedComponentIds, shouldForwardProp = forwardedComponent.shouldForwardProp, styledComponentId = forwardedComponent.styledComponentId, target = forwardedComponent.target;\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    if (true)\n        React.useDebugValue(styledComponentId);\n    // NOTE: the non-hooks version only subscribes to this when !componentStyle.isStatic,\n    // but that'd be against the rules-of-hooks. We could be naughty and do it anyway as it\n    // should be an immutable value, but behave for now.\n    var theme = determineTheme(props, React.useContext(ThemeContext), defaultProps) || EMPTY_OBJECT;\n    var context = componentAttrs.reduce(function (p, attrDef) {\n        var resolvedAttrDef = typeof attrDef === 'function' ? attrDef(p) : attrDef;\n        /* eslint-disable guard-for-in */\n        for (var key in resolvedAttrDef) {\n            // @ts-expect-error bad types\n            p[key] =\n                key === 'className'\n                    ? joinStrings(p[key], resolvedAttrDef[key])\n                    : key === 'style'\n                        ? tslib.__assign(tslib.__assign({}, p[key]), resolvedAttrDef[key]) : resolvedAttrDef[key];\n        }\n        /* eslint-enable guard-for-in */\n        return p;\n    }, tslib.__assign(tslib.__assign({}, props), { theme: theme }));\n    var generatedClassName = useInjectedStyle(componentStyle, isStatic, context,  true ? forwardedComponent.warnTooManyClasses : 0);\n    var refToForward = forwardedRef;\n    var elementToBeCreated = context.as || target;\n    var isTargetTag = isTag(elementToBeCreated);\n    var propsForElement = {};\n    // eslint-disable-next-line guard-for-in\n    for (var key in context) {\n        // @ts-expect-error for..in iterates strings instead of keyof\n        if (context[key] === undefined) ;\n        else if (key[0] === '$' || key === 'as' || key === 'theme') ;\n        else if (key === 'forwardedAs') {\n            propsForElement.as = context.forwardedAs;\n        }\n        else if (!shouldForwardProp || shouldForwardProp(key, elementToBeCreated)) {\n            // @ts-expect-error for..in iterates strings instead of keyof\n            propsForElement[key] = context[key];\n        }\n    }\n    propsForElement[\n    // handle custom elements which React doesn't properly alias\n    isTargetTag &&\n        domElements.indexOf(elementToBeCreated) === -1\n        ? 'class'\n        : 'className'] = foldedComponentIds\n        .concat(styledComponentId, generatedClassName !== styledComponentId ? generatedClassName : '', context.className || '')\n        .filter(Boolean)\n        .join(' ');\n    propsForElement.ref = refToForward;\n    return React.createElement(elementToBeCreated, propsForElement);\n}\nfunction createStyledComponent(target, options, rules) {\n    var isTargetStyledComp = isStyledComponent(target);\n    var styledComponentTarget = target;\n    var isCompositeComponent = !isTag(target);\n    var _a = options.attrs, attrs = _a === void 0 ? EMPTY_ARRAY : _a, _b = options.componentId, componentId = _b === void 0 ? generateId(options.displayName, options.parentComponentId) : _b, _c = options.displayName, displayName = _c === void 0 ? generateDisplayName(target) : _c;\n    var styledComponentId = options.displayName && options.componentId\n        ? \"\".concat(escape(options.displayName), \"-\").concat(options.componentId)\n        : options.componentId || componentId;\n    // fold the underlying StyledComponent attrs up (implicit extend)\n    var finalAttrs = isTargetStyledComp && styledComponentTarget.attrs\n        ? styledComponentTarget.attrs\n            .concat(attrs)\n            .filter(Boolean)\n        : attrs;\n    var shouldForwardProp = options.shouldForwardProp;\n    if (isTargetStyledComp && styledComponentTarget.shouldForwardProp) {\n        var shouldForwardPropFn_1 = styledComponentTarget.shouldForwardProp;\n        if (options.shouldForwardProp) {\n            var passedShouldForwardPropFn_1 = options.shouldForwardProp;\n            // compose nested shouldForwardProp calls\n            shouldForwardProp = function (prop, elementToBeCreated) {\n                return shouldForwardPropFn_1(prop, elementToBeCreated) &&\n                    passedShouldForwardPropFn_1(prop, elementToBeCreated);\n            };\n        }\n        else {\n            shouldForwardProp = shouldForwardPropFn_1;\n        }\n    }\n    var componentStyle = new ComponentStyle(rules, styledComponentId, isTargetStyledComp ? styledComponentTarget.componentStyle : undefined);\n    // statically styled-components don't need to build an execution context object,\n    // and shouldn't be increasing the number of class names\n    var isStatic = componentStyle.isStatic && attrs.length === 0;\n    function forwardRef(props, ref) {\n        // eslint-disable-next-line\n        return useStyledComponentImpl(WrappedStyledComponent, props, ref, isStatic);\n    }\n    forwardRef.displayName = displayName;\n    /**\n     * forwardRef creates a new interim component, which we'll take advantage of\n     * instead of extending ParentComponent to create _another_ interim class\n     */\n    var WrappedStyledComponent = React__default.default.forwardRef(forwardRef);\n    WrappedStyledComponent.attrs = finalAttrs;\n    WrappedStyledComponent.componentStyle = componentStyle;\n    WrappedStyledComponent.displayName = displayName;\n    WrappedStyledComponent.shouldForwardProp = shouldForwardProp;\n    // this static is used to preserve the cascade of static classes for component selector\n    // purposes; this is especially important with usage of the css prop\n    WrappedStyledComponent.foldedComponentIds = isTargetStyledComp\n        ? styledComponentTarget.foldedComponentIds.concat(styledComponentTarget.styledComponentId)\n        : EMPTY_ARRAY;\n    WrappedStyledComponent.styledComponentId = styledComponentId;\n    // fold the underlying StyledComponent target up since we folded the styles\n    WrappedStyledComponent.target = isTargetStyledComp ? styledComponentTarget.target : target;\n    Object.defineProperty(WrappedStyledComponent, 'defaultProps', {\n        get: function () {\n            return this._foldedDefaultProps;\n        },\n        set: function (obj) {\n            this._foldedDefaultProps = isTargetStyledComp\n                ? mixinDeep({}, styledComponentTarget.defaultProps, obj)\n                : obj;\n        },\n    });\n    if (true) {\n        checkDynamicCreation(displayName, styledComponentId);\n        WrappedStyledComponent.warnTooManyClasses = createWarnTooManyClasses(displayName, styledComponentId);\n    }\n    WrappedStyledComponent.toString = function () { return \".\".concat(WrappedStyledComponent.styledComponentId); };\n    if (isCompositeComponent) {\n        var compositeComponentTarget = target;\n        hoistNonReactStatics(WrappedStyledComponent, compositeComponentTarget, {\n            // all SC-specific things should not be hoisted\n            attrs: true,\n            componentStyle: true,\n            displayName: true,\n            foldedComponentIds: true,\n            shouldForwardProp: true,\n            styledComponentId: true,\n            target: true,\n        });\n    }\n    return WrappedStyledComponent;\n}\n\nfunction interleave(strings, interpolations) {\n    var result = [strings[0]];\n    for (var i = 0, len = interpolations.length; i < len; i += 1) {\n        result.push(interpolations[i], strings[i + 1]);\n    }\n    return result;\n}\n\n/**\n * Used when flattening object styles to determine if we should\n * expand an array of styles.\n */\nvar addTag = function (arg) {\n    return Object.assign(arg, { isCss: true });\n};\nfunction css(styles) {\n    var interpolations = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        interpolations[_i - 1] = arguments[_i];\n    }\n    if (isFunction(styles) || isPlainObject(styles)) {\n        var styleFunctionOrObject = styles;\n        return addTag(flatten(interleave(EMPTY_ARRAY, tslib.__spreadArray([\n            styleFunctionOrObject\n        ], interpolations, true))));\n    }\n    var styleStringArray = styles;\n    if (interpolations.length === 0 &&\n        styleStringArray.length === 1 &&\n        typeof styleStringArray[0] === 'string') {\n        return flatten(styleStringArray);\n    }\n    return addTag(flatten(interleave(styleStringArray, interpolations)));\n}\n\nfunction constructWithOptions(componentConstructor, tag, options) {\n    if (options === void 0) { options = EMPTY_OBJECT; }\n    // We trust that the tag is a valid component as long as it isn't falsish\n    // Typically the tag here is a string or function (i.e. class or pure function component)\n    // However a component may also be an object if it uses another utility, e.g. React.memo\n    // React will output an appropriate warning however if the `tag` isn't valid\n    if (!tag) {\n        throw throwStyledComponentsError(1, tag);\n    }\n    /* This is callable directly as a template function */\n    var templateFunction = function (initialStyles) {\n        var interpolations = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            interpolations[_i - 1] = arguments[_i];\n        }\n        return componentConstructor(tag, options, css.apply(void 0, tslib.__spreadArray([initialStyles], interpolations, false)));\n    };\n    /* Modify/inject new props at runtime */\n    templateFunction.attrs = function (attrs) {\n        return constructWithOptions(componentConstructor, tag, tslib.__assign(tslib.__assign({}, options), { attrs: Array.prototype.concat(options.attrs, attrs).filter(Boolean) }));\n    };\n    /**\n     * If config methods are called, wrap up a new template function and merge options */\n    templateFunction.withConfig = function (config) {\n        return constructWithOptions(componentConstructor, tag, tslib.__assign(tslib.__assign({}, options), config));\n    };\n    return templateFunction;\n}\n\nvar baseStyled = function (tag) {\n    return constructWithOptions(createStyledComponent, tag);\n};\nvar styled = baseStyled;\n// Shorthands for all valid HTML Elements\ndomElements.forEach(function (domElement) {\n    // @ts-expect-error someday they'll handle imperative assignment properly\n    styled[domElement] = baseStyled(domElement);\n});\n\nvar GlobalStyle = /** @class */ (function () {\n    function GlobalStyle(rules, componentId) {\n        this.rules = rules;\n        this.componentId = componentId;\n        this.isStatic = isStaticRules(rules);\n        // pre-register the first instance to ensure global styles\n        // load before component ones\n        StyleSheet.registerId(this.componentId + 1);\n    }\n    GlobalStyle.prototype.createStyles = function (instance, executionContext, styleSheet, stylis) {\n        var flatCSS = flatten(this.rules, executionContext, styleSheet, stylis);\n        var css = stylis(flatCSS.join(''), '');\n        var id = this.componentId + instance;\n        // NOTE: We use the id as a name as well, since these rules never change\n        styleSheet.insertRules(id, id, css);\n    };\n    GlobalStyle.prototype.removeStyles = function (instance, styleSheet) {\n        styleSheet.clearRules(this.componentId + instance);\n    };\n    GlobalStyle.prototype.renderStyles = function (instance, executionContext, styleSheet, stylis) {\n        if (instance > 2)\n            StyleSheet.registerId(this.componentId + instance);\n        // NOTE: Remove old styles, then inject the new ones\n        this.removeStyles(instance, styleSheet);\n        this.createStyles(instance, executionContext, styleSheet, stylis);\n    };\n    return GlobalStyle;\n}());\n\nfunction createGlobalStyle(strings) {\n    var interpolations = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        interpolations[_i - 1] = arguments[_i];\n    }\n    var rules = css.apply(void 0, tslib.__spreadArray([strings], interpolations, false));\n    var styledComponentId = \"sc-global-\".concat(generateComponentId(JSON.stringify(rules)));\n    var globalStyle = new GlobalStyle(rules, styledComponentId);\n    if (true) {\n        checkDynamicCreation(styledComponentId);\n    }\n    var GlobalStyleComponent = function (props) {\n        var styleSheet = useStyleSheet();\n        var stylis = useStylis();\n        var theme = React__default.default.useContext(ThemeContext);\n        var instanceRef = React__default.default.useRef(styleSheet.allocateGSInstance(styledComponentId));\n        var instance = instanceRef.current;\n        if ( true && React__default.default.Children.count(props.children)) {\n            // eslint-disable-next-line no-console\n            console.warn(\"The global style component \".concat(styledComponentId, \" was given child JSX. createGlobalStyle does not render children.\"));\n        }\n        if ( true &&\n            rules.some(function (rule) { return typeof rule === 'string' && rule.indexOf('@import') !== -1; })) {\n            // eslint-disable-next-line no-console\n            console.warn(\"Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app.\");\n        }\n        if (styleSheet.server) {\n            renderStyles(instance, props, styleSheet, theme, stylis);\n        }\n        return null;\n    };\n    function renderStyles(instance, props, styleSheet, theme, stylis) {\n        if (globalStyle.isStatic) {\n            globalStyle.renderStyles(instance, STATIC_EXECUTION_CONTEXT, styleSheet, stylis);\n        }\n        else {\n            var context = tslib.__assign(tslib.__assign({}, props), { theme: determineTheme(props, theme, GlobalStyleComponent.defaultProps) });\n            globalStyle.renderStyles(instance, context, styleSheet, stylis);\n        }\n    }\n    return React__default.default.memo(GlobalStyleComponent);\n}\n\nfunction keyframes(strings) {\n    var interpolations = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        interpolations[_i - 1] = arguments[_i];\n    }\n    /* Warning if you've used keyframes on React Native */\n    if ( true &&\n        typeof navigator !== 'undefined' &&\n        navigator.product === 'ReactNative') {\n        // eslint-disable-next-line no-console\n        console.warn('`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.');\n    }\n    var rules = css.apply(void 0, tslib.__spreadArray([strings], interpolations, false)).join('');\n    var name = generateComponentId(rules);\n    return new Keyframes(name, rules);\n}\n\nfunction withTheme(Component) {\n    var WithTheme = React__default.default.forwardRef(function (props, ref) {\n        var theme = React__default.default.useContext(ThemeContext);\n        var themeProp = determineTheme(props, theme, Component.defaultProps);\n        if ( true && themeProp === undefined) {\n            // eslint-disable-next-line no-console\n            console.warn(\"[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class \\\"\".concat(getComponentName(Component), \"\\\"\"));\n        }\n        return React__default.default.createElement(Component, tslib.__assign({}, props, { theme: themeProp, ref: ref }));\n    });\n    WithTheme.displayName = \"WithTheme(\".concat(getComponentName(Component), \")\");\n    return hoistNonReactStatics(WithTheme, Component);\n}\n\nvar useTheme = function () { return React.useContext(ThemeContext); };\n\nvar CLOSING_TAG_R = /^\\s*<\\/[a-z]/i;\nvar ServerStyleSheet = /** @class */ (function () {\n    function ServerStyleSheet() {\n        var _this = this;\n        this._emitSheetCSS = function () {\n            var css = _this.instance.toString();\n            var nonce = getNonce();\n            var attrs = [\n                nonce && \"nonce=\\\"\".concat(nonce, \"\\\"\"),\n                \"\".concat(SC_ATTR, \"=\\\"true\\\"\"),\n                \"\".concat(SC_ATTR_VERSION, \"=\\\"\").concat(SC_VERSION, \"\\\"\"),\n            ];\n            var htmlAttr = attrs.filter(Boolean).join(' ');\n            return \"<style \".concat(htmlAttr, \">\").concat(css, \"</style>\");\n        };\n        this.getStyleTags = function () {\n            if (_this.sealed) {\n                throw throwStyledComponentsError(2);\n            }\n            return _this._emitSheetCSS();\n        };\n        this.getStyleElement = function () {\n            var _a;\n            if (_this.sealed) {\n                throw throwStyledComponentsError(2);\n            }\n            var props = (_a = {},\n                _a[SC_ATTR] = '',\n                _a[SC_ATTR_VERSION] = SC_VERSION,\n                _a.dangerouslySetInnerHTML = {\n                    __html: _this.instance.toString(),\n                },\n                _a);\n            var nonce = getNonce();\n            if (nonce) {\n                props.nonce = nonce;\n            }\n            // v4 returned an array for this fn, so we'll do the same for v5 for backward compat\n            return [React__default.default.createElement(\"style\", tslib.__assign({}, props, { key: \"sc-0-0\" }))];\n        };\n        this.seal = function () {\n            _this.sealed = true;\n        };\n        this.instance = new StyleSheet({ isServer: true });\n        this.sealed = false;\n    }\n    ServerStyleSheet.prototype.collectStyles = function (children) {\n        if (this.sealed) {\n            throw throwStyledComponentsError(2);\n        }\n        return React__default.default.createElement(StyleSheetManager, { sheet: this.instance }, children);\n    };\n    // eslint-disable-next-line consistent-return\n    // @ts-expect-error alternate return types are not possible due to code transformation\n    ServerStyleSheet.prototype.interleaveWithNodeStream = function (input) {\n        if (this.sealed) {\n            throw throwStyledComponentsError(2);\n        }\n        {\n            this.seal();\n            // eslint-disable-next-line global-require, @typescript-eslint/no-var-requires\n            var Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\n            var readableStream = input;\n            var _a = this, sheet_1 = _a.instance, _emitSheetCSS_1 = _a._emitSheetCSS;\n            var transformer_1 = new Transform({\n                transform: function appendStyleChunks(chunk, \n                /* encoding */\n                _, callback) {\n                    // Get the chunk and retrieve the sheet's CSS as an HTML chunk,\n                    // then reset its rules so we get only new ones for the next chunk\n                    var renderedHtml = chunk.toString();\n                    var html = _emitSheetCSS_1();\n                    sheet_1.clearTag();\n                    // prepend style html to chunk, unless the start of the chunk is a\n                    // closing tag in which case append right after that\n                    if (CLOSING_TAG_R.test(renderedHtml)) {\n                        var endOfClosingTag = renderedHtml.indexOf('>') + 1;\n                        var before = renderedHtml.slice(0, endOfClosingTag);\n                        var after = renderedHtml.slice(endOfClosingTag);\n                        this.push(before + html + after);\n                    }\n                    else {\n                        this.push(html + renderedHtml);\n                    }\n                    callback();\n                },\n            });\n            readableStream.on('error', function (err) {\n                // forward the error to the transform stream\n                transformer_1.emit('error', err);\n            });\n            return readableStream.pipe(transformer_1);\n        }\n    };\n    return ServerStyleSheet;\n}());\n\n/* eslint-disable */\nvar __PRIVATE__ = {\n    StyleSheet: StyleSheet,\n    mainSheet: mainSheet,\n};\n\n/* Import singletons */\n/* Warning if you've imported this file on React Native */\nif ( true &&\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative') {\n    // eslint-disable-next-line no-console\n    console.warn(\"It looks like you've imported 'styled-components' on React Native.\\n\" +\n        \"Perhaps you're looking to import 'styled-components/native'?\\n\" +\n        'Read more about this at https://www.styled-components.com/docs/basics#react-native');\n}\n/* Warning if there are several instances of styled-components */\nif (false) {}\n\nexports.ServerStyleSheet = ServerStyleSheet;\nexports.StyleSheetConsumer = StyleSheetConsumer;\nexports.StyleSheetContext = StyleSheetContext;\nexports.StyleSheetManager = StyleSheetManager;\nexports.ThemeConsumer = ThemeConsumer;\nexports.ThemeContext = ThemeContext;\nexports.ThemeProvider = ThemeProvider;\nexports.__PRIVATE__ = __PRIVATE__;\nexports.createGlobalStyle = createGlobalStyle;\nexports.css = css;\nexports[\"default\"] = styled;\nexports.isStyledComponent = isStyledComponent;\nexports.keyframes = keyframes;\nexports.styled = styled;\nexports.useTheme = useTheme;\nexports.version = SC_VERSION;\nexports.withTheme = withTheme;\n//# sourceMappingURL=styled-components.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc3R5bGVkLWNvbXBvbmVudHMvZGlzdC9zdHlsZWQtY29tcG9uZW50cy5janMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxZQUFZLG1CQUFPLENBQUMsb0JBQU87QUFDM0IsWUFBWSxtQkFBTyxDQUFDLG9CQUFPO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLGtDQUFjO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixlQUFlLG1CQUFPLENBQUMsNENBQW1COztBQUUxQywrQkFBK0IsaUNBQWlDOztBQUVoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFvQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRSxpQ0FBaUM7QUFDakM7QUFDQSwwQkFBMEI7QUFDMUIsd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYSxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsS0FBcUMsMENBQTBDLENBQUs7QUFDakc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsS0FBcUM7QUFDOUM7QUFDQSxjQUFjLENBQUk7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx1Q0FBdUM7QUFDdkMsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNENBQTRDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlDQUFpQztBQUNqQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsR0FBRztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUgsc0JBQXNCO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzQkFBc0I7QUFDekU7QUFDQTtBQUNBLG1EQUFtRCwwQkFBMEI7QUFDN0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLGtFQUFrRTtBQUN6RjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtFQUErRSxtQkFBbUI7QUFDbEcsdUVBQXVFLGVBQWUsRUFBRSxLQUFxQztBQUM3SDtBQUNBLGNBQWMsQ0FBYztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0Esb0ZBQW9GLHNCQUFzQjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQXFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQ21EO0FBQy9ELGdCQUFnQixDQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixJQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNkNBQTZDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxxQkFBcUI7QUFDOUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLEtBQUssa0NBQWtDLFlBQVksY0FBYztBQUNqRSxpRkFBaUYsS0FBcUMsMkNBQTJDLENBQVM7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsY0FBYyxxRUFBcUU7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFxQztBQUNqRCx5Q0FBeUMsb0VBQW9FO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVksd0VBQXdFO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixXQUFXLDRCQUE0QjtBQUN2SCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsV0FBVyxlQUFlO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsc0JBQXNCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVEQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksS0FBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FFZ0MsRUFBRSxFQUlyQzs7QUFFRCx3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QixXQUFXO0FBQ1gsa0JBQWU7QUFDZix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbmRib3gvLi4vc3R5bGVkLWNvbXBvbmVudHMvZGlzdC9zdHlsZWQtY29tcG9uZW50cy5janMuanM/MWZlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHNoYWxsb3dlcXVhbCA9IHJlcXVpcmUoJ3NoYWxsb3dlcXVhbCcpO1xudmFyIHN0eWxpcyA9IHJlcXVpcmUoJ3N0eWxpcycpO1xudmFyIHVuaXRsZXNzID0gcmVxdWlyZSgnQGVtb3Rpb24vdW5pdGxlc3MnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuXG52YXIgUmVhY3RfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KFJlYWN0KTtcbnZhciBzaGFsbG93ZXF1YWxfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KHNoYWxsb3dlcXVhbCk7XG52YXIgdW5pdGxlc3NfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KHVuaXRsZXNzKTtcblxudmFyIFNDX0FUVFIgPSAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIChwcm9jZXNzLmVudi5SRUFDVF9BUFBfU0NfQVRUUiB8fCBwcm9jZXNzLmVudi5TQ19BVFRSKSkgfHxcbiAgICAnZGF0YS1zdHlsZWQnO1xudmFyIFNDX0FUVFJfQUNUSVZFID0gJ2FjdGl2ZSc7XG52YXIgU0NfQVRUUl9WRVJTSU9OID0gJ2RhdGEtc3R5bGVkLXZlcnNpb24nO1xudmFyIFNDX1ZFUlNJT04gPSBcIjYuMC4wLWJldGEuOFwiO1xudmFyIFNQTElUVEVSID0gJy8qIXNjKi9cXG4nO1xudmFyIElTX0JST1dTRVIgPSB0eXBlb2YgdW5kZWZpbmVkICE9PSAndW5kZWZpbmVkJyA7XG52YXIgRElTQUJMRV9TUEVFRFkgPSBCb29sZWFuKHR5cGVvZiBTQ19ESVNBQkxFX1NQRUVEWSA9PT0gJ2Jvb2xlYW4nXG4gICAgPyBTQ19ESVNBQkxFX1NQRUVEWVxuICAgIDogdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBwcm9jZXNzLmVudi5SRUFDVF9BUFBfU0NfRElTQUJMRV9TUEVFRFkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHByb2Nlc3MuZW52LlJFQUNUX0FQUF9TQ19ESVNBQkxFX1NQRUVEWSAhPT0gJydcbiAgICAgICAgPyBwcm9jZXNzLmVudi5SRUFDVF9BUFBfU0NfRElTQUJMRV9TUEVFRFkgPT09ICdmYWxzZSdcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogcHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX1NDX0RJU0FCTEVfU1BFRURZXG4gICAgICAgIDogdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YgcHJvY2Vzcy5lbnYuU0NfRElTQUJMRV9TUEVFRFkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5TQ19ESVNBQkxFX1NQRUVEWSAhPT0gJydcbiAgICAgICAgICAgID8gcHJvY2Vzcy5lbnYuU0NfRElTQUJMRV9TUEVFRFkgPT09ICdmYWxzZSdcbiAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiBwcm9jZXNzLmVudi5TQ19ESVNBQkxFX1NQRUVEWVxuICAgICAgICAgICAgOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKTtcbi8vIFNoYXJlZCBlbXB0eSBleGVjdXRpb24gY29udGV4dCB3aGVuIGdlbmVyYXRpbmcgc3RhdGljIHN0eWxlc1xudmFyIFNUQVRJQ19FWEVDVVRJT05fQ09OVEVYVCA9IHt9O1xuXG52YXIgaW52YWxpZEhvb2tDYWxsUmUgPSAvaW52YWxpZCBob29rIGNhbGwvaTtcbnZhciBzZWVuID0gbmV3IFNldCgpO1xudmFyIGNoZWNrRHluYW1pY0NyZWF0aW9uID0gZnVuY3Rpb24gKGRpc3BsYXlOYW1lLCBjb21wb25lbnRJZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBwYXJzZWRJZFN0cmluZyA9IGNvbXBvbmVudElkID8gXCIgd2l0aCB0aGUgaWQgb2YgXFxcIlwiLmNvbmNhdChjb21wb25lbnRJZCwgXCJcXFwiXCIpIDogJyc7XG4gICAgICAgIHZhciBtZXNzYWdlXzEgPSBcIlRoZSBjb21wb25lbnQgXCIuY29uY2F0KGRpc3BsYXlOYW1lKS5jb25jYXQocGFyc2VkSWRTdHJpbmcsIFwiIGhhcyBiZWVuIGNyZWF0ZWQgZHluYW1pY2FsbHkuXFxuXCIpICtcbiAgICAgICAgICAgIFwiWW91IG1heSBzZWUgdGhpcyB3YXJuaW5nIGJlY2F1c2UgeW91J3ZlIGNhbGxlZCBzdHlsZWQgaW5zaWRlIGFub3RoZXIgY29tcG9uZW50LlxcblwiICtcbiAgICAgICAgICAgICdUbyByZXNvbHZlIHRoaXMgb25seSBjcmVhdGUgbmV3IFN0eWxlZENvbXBvbmVudHMgb3V0c2lkZSBvZiBhbnkgcmVuZGVyIG1ldGhvZCBhbmQgZnVuY3Rpb24gY29tcG9uZW50Lic7XG4gICAgICAgIC8vIElmIGEgaG9vayBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGNvbXBvbmVudDpcbiAgICAgICAgLy8gUmVhY3QgMTcgYW5kIGVhcmxpZXIgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgLy8gUmVhY3QgMTggYW5kIGFib3ZlIHVzZSBjb25zb2xlLmVycm9yXG4gICAgICAgIHZhciBvcmlnaW5hbENvbnNvbGVFcnJvcl8xID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBkaWROb3RDYWxsSW52YWxpZEhvb2tfMSA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yID0gZnVuY3Rpb24gKGNvbnNvbGVFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uc29sZUVycm9yQXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGVFcnJvckFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZSBlcnJvciBoZXJlIGlzIGV4cGVjdGVkLCBzaW5jZSB3ZSdyZSBleHBlY3RpbmcgYW55dGhpbmcgdGhhdCB1c2VzIGBjaGVja0R5bmFtaWNDcmVhdGlvbmAgdG9cbiAgICAgICAgICAgICAgICAvLyBiZSBjYWxsZWQgb3V0c2lkZSBvZiBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICBpZiAoaW52YWxpZEhvb2tDYWxsUmUudGVzdChjb25zb2xlRXJyb3JNZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICBkaWROb3RDYWxsSW52YWxpZEhvb2tfMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4sIGJ1dCByZXNldHMgYHdhcm5pbmdTZWVuYCBpZiB3ZSBoYWQgdGhpcyBlcnJvciBoYXBwZW4gaW50ZXJtaXR0ZW50bHlcbiAgICAgICAgICAgICAgICAgICAgc2Vlbi5kZWxldGUobWVzc2FnZV8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29uc29sZUVycm9yXzEuYXBwbHkodm9pZCAwLCB0c2xpYi5fX3NwcmVhZEFycmF5KFtjb25zb2xlRXJyb3JNZXNzYWdlXSwgY29uc29sZUVycm9yQXJncywgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gV2UgcHVycG9zZWZ1bGx5IGNhbGwgYHVzZVJlZmAgb3V0c2lkZSBvZiBhIGNvbXBvbmVudCBhbmQgZXhwZWN0IGl0IHRvIHRocm93XG4gICAgICAgICAgICAvLyBJZiBpdCBkb2Vzbid0LCB0aGVuIHdlJ3JlIGluc2lkZSBhbm90aGVyIGNvbXBvbmVudC5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICAgICAgUmVhY3QudXNlUmVmKCk7XG4gICAgICAgICAgICBpZiAoZGlkTm90Q2FsbEludmFsaWRIb29rXzEgJiYgIXNlZW4uaGFzKG1lc3NhZ2VfMSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlXzEpO1xuICAgICAgICAgICAgICAgIHNlZW4uYWRkKG1lc3NhZ2VfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBUaGUgZXJyb3IgaGVyZSBpcyBleHBlY3RlZCwgc2luY2Ugd2UncmUgZXhwZWN0aW5nIGFueXRoaW5nIHRoYXQgdXNlcyBgY2hlY2tEeW5hbWljQ3JlYXRpb25gIHRvXG4gICAgICAgICAgICAvLyBiZSBjYWxsZWQgb3V0c2lkZSBvZiBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICAgICAgICAgIGlmIChpbnZhbGlkSG9va0NhbGxSZS50ZXN0KGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBidXQgcmVzZXRzIGB3YXJuaW5nU2VlbmAgaWYgd2UgaGFkIHRoaXMgZXJyb3IgaGFwcGVuIGludGVybWl0dGVudGx5XG4gICAgICAgICAgICAgICAgc2Vlbi5kZWxldGUobWVzc2FnZV8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IgPSBvcmlnaW5hbENvbnNvbGVFcnJvcl8xO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIExJTUlUID0gMjAwO1xudmFyIGNyZWF0ZVdhcm5Ub29NYW55Q2xhc3NlcyA9IChmdW5jdGlvbiAoZGlzcGxheU5hbWUsIGNvbXBvbmVudElkKSB7XG4gICAgdmFyIGdlbmVyYXRlZENsYXNzZXMgPSB7fTtcbiAgICB2YXIgd2FybmluZ1NlZW4gPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoIXdhcm5pbmdTZWVuKSB7XG4gICAgICAgICAgICBnZW5lcmF0ZWRDbGFzc2VzW2NsYXNzTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGdlbmVyYXRlZENsYXNzZXMpLmxlbmd0aCA+PSBMSU1JVCkge1xuICAgICAgICAgICAgICAgIC8vIFVuYWJsZSB0byBmaW5kIGxhdGVzdFJ1bGUgaW4gdGVzdCBlbnZpcm9ubWVudC5cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlLCBwcmVmZXItdGVtcGxhdGUgKi9cbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkSWRTdHJpbmcgPSBjb21wb25lbnRJZCA/IFwiIHdpdGggdGhlIGlkIG9mIFxcXCJcIi5jb25jYXQoY29tcG9uZW50SWQsIFwiXFxcIlwiKSA6ICcnO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk92ZXIgXCIuY29uY2F0KExJTUlULCBcIiBjbGFzc2VzIHdlcmUgZ2VuZXJhdGVkIGZvciBjb21wb25lbnQgXCIpLmNvbmNhdChkaXNwbGF5TmFtZSkuY29uY2F0KHBhcnNlZElkU3RyaW5nLCBcIi5cXG5cIikgK1xuICAgICAgICAgICAgICAgICAgICAnQ29uc2lkZXIgdXNpbmcgdGhlIGF0dHJzIG1ldGhvZCwgdG9nZXRoZXIgd2l0aCBhIHN0eWxlIG9iamVjdCBmb3IgZnJlcXVlbnRseSBjaGFuZ2VkIHN0eWxlcy5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgJ0V4YW1wbGU6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICcgIGNvbnN0IENvbXBvbmVudCA9IHN0eWxlZC5kaXYuYXR0cnMocHJvcHMgPT4gKHtcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgJyAgICBzdHlsZToge1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAnICAgICAgYmFja2dyb3VuZDogcHJvcHMuYmFja2dyb3VuZCxcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgJyAgICB9LFxcbicgK1xuICAgICAgICAgICAgICAgICAgICAnICB9KSlgd2lkdGg6IDEwMCU7YFxcblxcbicgK1xuICAgICAgICAgICAgICAgICAgICAnICA8Q29tcG9uZW50IC8+Jyk7XG4gICAgICAgICAgICAgICAgd2FybmluZ1NlZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZENsYXNzZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KTtcblxudmFyIEVNUFRZX0FSUkFZID0gT2JqZWN0LmZyZWV6ZShbXSk7XG52YXIgRU1QVFlfT0JKRUNUID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbmZ1bmN0aW9uIGRldGVybWluZVRoZW1lKHByb3BzLCBwcm92aWRlZFRoZW1lLCBkZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoZGVmYXVsdFByb3BzID09PSB2b2lkIDApIHsgZGVmYXVsdFByb3BzID0gRU1QVFlfT0JKRUNUOyB9XG4gICAgcmV0dXJuIChwcm9wcy50aGVtZSAhPT0gZGVmYXVsdFByb3BzLnRoZW1lICYmIHByb3BzLnRoZW1lKSB8fCBwcm92aWRlZFRoZW1lIHx8IGRlZmF1bHRQcm9wcy50aGVtZTtcbn1cblxuLy8gVGhhbmtzIHRvIFJlYWN0RE9NRmFjdG9yaWVzIGZvciB0aGlzIGhhbmR5IGxpc3QhXG52YXIgZG9tRWxlbWVudHMgPSBbXG4gICAgJ2EnLFxuICAgICdhYmJyJyxcbiAgICAnYWRkcmVzcycsXG4gICAgJ2FyZWEnLFxuICAgICdhcnRpY2xlJyxcbiAgICAnYXNpZGUnLFxuICAgICdhdWRpbycsXG4gICAgJ2InLFxuICAgICdiYXNlJyxcbiAgICAnYmRpJyxcbiAgICAnYmRvJyxcbiAgICAnYmlnJyxcbiAgICAnYmxvY2txdW90ZScsXG4gICAgJ2JvZHknLFxuICAgICdicicsXG4gICAgJ2J1dHRvbicsXG4gICAgJ2NhbnZhcycsXG4gICAgJ2NhcHRpb24nLFxuICAgICdjaXRlJyxcbiAgICAnY29kZScsXG4gICAgJ2NvbCcsXG4gICAgJ2NvbGdyb3VwJyxcbiAgICAnZGF0YScsXG4gICAgJ2RhdGFsaXN0JyxcbiAgICAnZGQnLFxuICAgICdkZWwnLFxuICAgICdkZXRhaWxzJyxcbiAgICAnZGZuJyxcbiAgICAnZGlhbG9nJyxcbiAgICAnZGl2JyxcbiAgICAnZGwnLFxuICAgICdkdCcsXG4gICAgJ2VtJyxcbiAgICAnZW1iZWQnLFxuICAgICdmaWVsZHNldCcsXG4gICAgJ2ZpZ2NhcHRpb24nLFxuICAgICdmaWd1cmUnLFxuICAgICdmb290ZXInLFxuICAgICdmb3JtJyxcbiAgICAnaDEnLFxuICAgICdoMicsXG4gICAgJ2gzJyxcbiAgICAnaDQnLFxuICAgICdoNScsXG4gICAgJ2g2JyxcbiAgICAnaGVhZCcsXG4gICAgJ2hlYWRlcicsXG4gICAgJ2hncm91cCcsXG4gICAgJ2hyJyxcbiAgICAnaHRtbCcsXG4gICAgJ2knLFxuICAgICdpZnJhbWUnLFxuICAgICdpbWcnLFxuICAgICdpbnB1dCcsXG4gICAgJ2lucycsXG4gICAgJ2tiZCcsXG4gICAgJ2tleWdlbicsXG4gICAgJ2xhYmVsJyxcbiAgICAnbGVnZW5kJyxcbiAgICAnbGknLFxuICAgICdsaW5rJyxcbiAgICAnbWFpbicsXG4gICAgJ21hcCcsXG4gICAgJ21hcmsnLFxuICAgICdtZW51JyxcbiAgICAnbWVudWl0ZW0nLFxuICAgICdtZXRhJyxcbiAgICAnbWV0ZXInLFxuICAgICduYXYnLFxuICAgICdub3NjcmlwdCcsXG4gICAgJ29iamVjdCcsXG4gICAgJ29sJyxcbiAgICAnb3B0Z3JvdXAnLFxuICAgICdvcHRpb24nLFxuICAgICdvdXRwdXQnLFxuICAgICdwJyxcbiAgICAncGFyYW0nLFxuICAgICdwaWN0dXJlJyxcbiAgICAncHJlJyxcbiAgICAncHJvZ3Jlc3MnLFxuICAgICdxJyxcbiAgICAncnAnLFxuICAgICdydCcsXG4gICAgJ3J1YnknLFxuICAgICdzJyxcbiAgICAnc2FtcCcsXG4gICAgJ3NjcmlwdCcsXG4gICAgJ3NlY3Rpb24nLFxuICAgICdzZWxlY3QnLFxuICAgICdzbWFsbCcsXG4gICAgJ3NvdXJjZScsXG4gICAgJ3NwYW4nLFxuICAgICdzdHJvbmcnLFxuICAgICdzdHlsZScsXG4gICAgJ3N1YicsXG4gICAgJ3N1bW1hcnknLFxuICAgICdzdXAnLFxuICAgICd0YWJsZScsXG4gICAgJ3Rib2R5JyxcbiAgICAndGQnLFxuICAgICd0ZXh0YXJlYScsXG4gICAgJ3Rmb290JyxcbiAgICAndGgnLFxuICAgICd0aGVhZCcsXG4gICAgJ3RpbWUnLFxuICAgICd0aXRsZScsXG4gICAgJ3RyJyxcbiAgICAndHJhY2snLFxuICAgICd1JyxcbiAgICAndWwnLFxuICAgICd2YXInLFxuICAgICd2aWRlbycsXG4gICAgJ3dicicsXG4gICAgJ2NpcmNsZScsXG4gICAgJ2NsaXBQYXRoJyxcbiAgICAnZGVmcycsXG4gICAgJ2VsbGlwc2UnLFxuICAgICdmb3JlaWduT2JqZWN0JyxcbiAgICAnZycsXG4gICAgJ2ltYWdlJyxcbiAgICAnbGluZScsXG4gICAgJ2xpbmVhckdyYWRpZW50JyxcbiAgICAnbWFya2VyJyxcbiAgICAnbWFzaycsXG4gICAgJ3BhdGgnLFxuICAgICdwYXR0ZXJuJyxcbiAgICAncG9seWdvbicsXG4gICAgJ3BvbHlsaW5lJyxcbiAgICAncmFkaWFsR3JhZGllbnQnLFxuICAgICdyZWN0JyxcbiAgICAnc3RvcCcsXG4gICAgJ3N2ZycsXG4gICAgJ3RleHQnLFxuICAgICd0c3BhbicsXG5dO1xuXG4vLyBTb3VyY2U6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3NvbS0xLyNzZXJpYWxpemUtYW4taWRlbnRpZmllclxuLy8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCBub24tbGV0dGVyIGZpcnN0IHN5bWJvbHMgYXJlIG5vdCBzdXBwb3J0ZWRcbnZhciBlc2NhcGVSZWdleCA9IC9bIVwiIyQlJicoKSorLC4vOjs8PT4/QFtcXFxcXFxdXmB7fH1+LV0rL2c7XG52YXIgZGFzaGVzQXRFbmRzID0gLyheLXwtJCkvZztcbi8qKlxuICogVE9ETzogRXhwbG9yZSB1c2luZyBDU1MuZXNjYXBlIHdoZW4gaXQgYmVjb21lcyBtb3JlIGF2YWlsYWJsZVxuICogaW4gZXZlcmdyZWVuIGJyb3dzZXJzLlxuICovXG5mdW5jdGlvbiBlc2NhcGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ciAvLyBSZXBsYWNlIGFsbCBwb3NzaWJsZSBDU1Mgc2VsZWN0b3JzXG4gICAgICAgIC5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnLScpIC8vIFJlbW92ZSBleHRyYW5lb3VzIGh5cGhlbnMgYXQgdGhlIHN0YXJ0IGFuZCBlbmRcbiAgICAgICAgLnJlcGxhY2UoZGFzaGVzQXRFbmRzLCAnJyk7XG59XG5cbnZhciBBRF9SRVBMQUNFUl9SID0gLyhhKShkKS9naTtcbi8qIFRoaXMgaXMgdGhlIFwiY2FwYWNpdHlcIiBvZiBvdXIgYWxwaGFiZXQgaS5lLiAyeDI2IGZvciBhbGwgbGV0dGVycyBwbHVzIHRoZWlyIGNhcGl0YWxpc2VkXG4gKiBjb3VudGVycGFydHMgKi9cbnZhciBjaGFyc0xlbmd0aCA9IDUyO1xuLyogc3RhcnQgYXQgNzUgZm9yICdhJyB1bnRpbCAneicgKDI1KSBhbmQgdGhlbiBzdGFydCBhdCA2NSBmb3IgY2FwaXRhbGlzZWQgbGV0dGVycyAqL1xudmFyIGdldEFscGhhYmV0aWNDaGFyID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSArIChjb2RlID4gMjUgPyAzOSA6IDk3KSk7IH07XG4vKiBpbnB1dCBhIG51bWJlciwgdXN1YWxseSBhIGhhc2ggYW5kIGNvbnZlcnQgaXQgdG8gYmFzZS01MiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVBbHBoYWJldGljTmFtZShjb2RlKSB7XG4gICAgdmFyIG5hbWUgPSAnJztcbiAgICB2YXIgeDtcbiAgICAvKiBnZXQgYSBjaGFyIGFuZCBkaXZpZGUgYnkgYWxwaGFiZXQtbGVuZ3RoICovXG4gICAgZm9yICh4ID0gTWF0aC5hYnMoY29kZSk7IHggPiBjaGFyc0xlbmd0aDsgeCA9ICh4IC8gY2hhcnNMZW5ndGgpIHwgMCkge1xuICAgICAgICBuYW1lID0gZ2V0QWxwaGFiZXRpY0NoYXIoeCAlIGNoYXJzTGVuZ3RoKSArIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiAoZ2V0QWxwaGFiZXRpY0NoYXIoeCAlIGNoYXJzTGVuZ3RoKSArIG5hbWUpLnJlcGxhY2UoQURfUkVQTEFDRVJfUiwgJyQxLSQyJyk7XG59XG5cbnZhciBTRUVEJDEgPSA1MzgxO1xuLy8gV2hlbiB3ZSBoYXZlIHNlcGFyYXRlIHN0cmluZ3MgaXQncyB1c2VmdWwgdG8gcnVuIGEgcHJvZ3Jlc3NpdmVcbi8vIHZlcnNpb24gb2YgZGpiMiB3aGVyZSB3ZSBwcmV0ZW5kIHRoYXQgd2UncmUgc3RpbGwgbG9vcGluZyBvdmVyXG4vLyB0aGUgc2FtZSBzdHJpbmdcbnZhciBwaGFzaCA9IGZ1bmN0aW9uIChoLCB4KSB7XG4gICAgdmFyIGkgPSB4Lmxlbmd0aDtcbiAgICB3aGlsZSAoaSkge1xuICAgICAgICBoID0gKGggKiAzMykgXiB4LmNoYXJDb2RlQXQoLS1pKTtcbiAgICB9XG4gICAgcmV0dXJuIGg7XG59O1xuLy8gVGhpcyBpcyBhIGRqYjIgaGFzaGluZyBmdW5jdGlvblxudmFyIGhhc2ggPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBwaGFzaChTRUVEJDEsIHgpO1xufTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDb21wb25lbnRJZChzdHIpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVBbHBoYWJldGljTmFtZShoYXNoKHN0cikgPj4+IDApO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHRhcmdldCkge1xuICAgIHJldHVybiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyAmJiB0YXJnZXQgOiBmYWxzZSkgfHxcbiAgICAgICAgdGFyZ2V0LmRpc3BsYXlOYW1lIHx8XG4gICAgICAgIHRhcmdldC5uYW1lIHx8XG4gICAgICAgICdDb21wb25lbnQnKTtcbn1cblxuZnVuY3Rpb24gaXNUYWcodGFyZ2V0KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgPyB0YXJnZXQuY2hhckF0KDApID09PSB0YXJnZXQuY2hhckF0KDApLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIDogdHJ1ZSkpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZURpc3BsYXlOYW1lKHRhcmdldCkge1xuICAgIHJldHVybiBpc1RhZyh0YXJnZXQpID8gXCJzdHlsZWQuXCIuY29uY2F0KHRhcmdldCkgOiBcIlN0eWxlZChcIi5jb25jYXQoZ2V0Q29tcG9uZW50TmFtZSh0YXJnZXQpLCBcIilcIik7XG59XG5cbnZhciBfYTtcbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG4vLyBjb3BpZWQgZnJvbSByZWFjdC1pc1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbi8qKlxuICogQWRhcHRlZCBmcm9tIGhvaXN0LW5vbi1yZWFjdC1zdGF0aWNzIHRvIGF2b2lkIHRoZSByZWFjdC1pcyBkZXBlbmRlbmN5LlxuICovXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgICBjb250ZXh0VHlwZXM6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6IHRydWUsXG4gICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZSxcbn07XG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgICBuYW1lOiB0cnVlLFxuICAgIGxlbmd0aDogdHJ1ZSxcbiAgICBwcm90b3R5cGU6IHRydWUsXG4gICAgY2FsbGVyOiB0cnVlLFxuICAgIGNhbGxlZTogdHJ1ZSxcbiAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgYXJpdHk6IHRydWUsXG59O1xudmFyIEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICAgJCR0eXBlb2Y6IHRydWUsXG4gICAgcmVuZGVyOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgICAkJHR5cGVvZjogdHJ1ZSxcbiAgICBjb21wYXJlOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZSxcbn07XG52YXIgVFlQRV9TVEFUSUNTID0gKF9hID0ge30sXG4gICAgX2FbUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRV0gPSBGT1JXQVJEX1JFRl9TVEFUSUNTLFxuICAgIF9hW1JFQUNUX01FTU9fVFlQRV0gPSBNRU1PX1NUQVRJQ1MsXG4gICAgX2EpO1xuLy8gYWRhcHRlZCBmcm9tIHJlYWN0LWlzXG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gICAgdmFyICQkdHlwZW9mVHlwZSA9ICd0eXBlJyBpbiBvYmplY3QgJiYgb2JqZWN0LnR5cGUuJCR0eXBlb2Y7XG4gICAgcmV0dXJuICQkdHlwZW9mVHlwZSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gZ2V0U3RhdGljcyhjb21wb25lbnQpIHtcbiAgICAvLyBSZWFjdCB2MTYuMTEgYW5kIGJlbG93XG4gICAgaWYgKGlzTWVtbyhjb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybiBNRU1PX1NUQVRJQ1M7XG4gICAgfVxuICAgIC8vIFJlYWN0IHYxNi4xMiBhbmQgYWJvdmVcbiAgICByZXR1cm4gJyQkdHlwZW9mJyBpbiBjb21wb25lbnRcbiAgICAgICAgPyBUWVBFX1NUQVRJQ1NbY29tcG9uZW50WyckJHR5cGVvZiddXVxuICAgICAgICA6IFJFQUNUX1NUQVRJQ1M7XG59XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGV4Y2x1ZGVsaXN0KSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBleGNsdWRlbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgICAgIHZhciBzb3VyY2VTdGF0aWNzID0gZ2V0U3RhdGljcyhzb3VyY2VDb21wb25lbnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIEtOT1dOX1NUQVRJQ1MpICYmXG4gICAgICAgICAgICAgICAgIShleGNsdWRlbGlzdCAmJiBleGNsdWRlbGlzdFtrZXldKSAmJlxuICAgICAgICAgICAgICAgICEoc291cmNlU3RhdGljcyAmJiBrZXkgaW4gc291cmNlU3RhdGljcykgJiZcbiAgICAgICAgICAgICAgICAhKHRhcmdldFN0YXRpY3MgJiYga2V5IGluIHRhcmdldFN0YXRpY3MpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGZhaWx1cmVzIGZyb20gcmVhZC1vbmx5IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBpZ25vcmUgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gaXNTdHlsZWRDb21wb25lbnQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmICdzdHlsZWRDb21wb25lbnRJZCcgaW4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBqb2luaW5nIHN0cmluZ3MgdG8gZm9ybSBjbGFzc05hbWUgY2hhaW5zXG4gKi9cbmZ1bmN0aW9uIGpvaW5TdHJpbmdzKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJncy5maWx0ZXIoQm9vbGVhbikuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHgpIHtcbiAgICByZXR1cm4gKHggIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHggPT09ICdvYmplY3QnICYmXG4gICAgICAgIC8qIGEgY2hlY2sgZm9yIGVtcHR5IHByb3RvdHlwZSB3b3VsZCBiZSBtb3JlIHR5cGljYWwsIGJ1dCB0aGF0XG4gICAgICAgICAgIGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggb2JqZWN0cyBjcmVhdGVkIGluIGRpZmZlcmVudCB2bSBjb250ZXh0cyAqL1xuICAgICAgICAoIXguY29uc3RydWN0b3IgfHwgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JykgJiZcbiAgICAgICAgKHgudG9TdHJpbmcgPyB4LnRvU3RyaW5nKCkgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkpID09PSAnW29iamVjdCBPYmplY3RdJyAmJlxuICAgICAgICAvKiBjaGVjayBmb3IgcmVhc29uYWJsZSBtYXJrZXJzIHRoYXQgdGhlIG9iamVjdCBpc24ndCBhbiBlbGVtZW50IGZvciByZWFjdCAmIHByZWFjdC9jb21wYXQgKi9cbiAgICAgICAgISgncHJvcHMnIGluIHggJiYgKHguJCR0eXBlb2YgfHwgeC5jb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSkpO1xufVxuXG5mdW5jdGlvbiBtaXhpblJlY3Vyc2l2ZWx5KHRhcmdldCwgc291cmNlLCBmb3JjZU1lcmdlKSB7XG4gICAgaWYgKGZvcmNlTWVyZ2UgPT09IHZvaWQgMCkgeyBmb3JjZU1lcmdlID0gZmFsc2U7IH1cbiAgICAvKiBvbmx5IG1lcmdlIGludG8gUE9KT3MsIEFycmF5cywgYnV0IGZvciB0b3AgbGV2ZWwgb2JqZWN0cyBvbmx5XG4gICAgICogYWxsb3cgdG8gbWVyZ2UgaW50byBhbnl0aGluZyBieSBwYXNzaW5nIGZvcmNlTWVyZ2UgPSB0cnVlICovXG4gICAgaWYgKCFmb3JjZU1lcmdlICYmICFpc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIGZvciAodmFyIGtleSA9IDA7IGtleSA8IHNvdXJjZS5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1peGluUmVjdXJzaXZlbHkodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtaXhpblJlY3Vyc2l2ZWx5KHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogQXJyYXlzICYgUE9KT3MgbWVyZ2VkIHJlY3Vyc2l2ZWx5LCBvdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlblxuICogSWYgdGFyZ2V0IGlzIG5vdCBhIFBPSk8gb3IgYW4gQXJyYXksIGl0IHdpbGwgZ2V0IHNvdXJjZSBwcm9wZXJ0aWVzIGluamVjdGVkIHZpYSBzaGFsbG93IG1lcmdlXG4gKiBTb3VyY2Ugb2JqZWN0cyBhcHBsaWVkIGxlZnQgdG8gcmlnaHQuICBNdXRhdGVzICYgcmV0dXJucyB0YXJnZXQuICBTaW1pbGFyIHRvIGxvZGFzaCBtZXJnZS5cbiAqL1xuZnVuY3Rpb24gbWl4aW5EZWVwKHRhcmdldCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2EgPSAwLCBzb3VyY2VzXzEgPSBzb3VyY2VzOyBfYSA8IHNvdXJjZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNfMVtfYV07XG4gICAgICAgIG1peGluUmVjdXJzaXZlbHkodGFyZ2V0LCBzb3VyY2UsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgZXJyb3JNYXAgPSB7XG4gICAgJzEnOiAnQ2Fubm90IGNyZWF0ZSBzdHlsZWQtY29tcG9uZW50IGZvciBjb21wb25lbnQ6ICVzLlxcblxcbicsXG4gICAgJzInOiBcIkNhbid0IGNvbGxlY3Qgc3R5bGVzIG9uY2UgeW91J3ZlIGNvbnN1bWVkIGEgYFNlcnZlclN0eWxlU2hlZXRgJ3Mgc3R5bGVzISBgU2VydmVyU3R5bGVTaGVldGAgaXMgYSBvbmUgb2ZmIGluc3RhbmNlIGZvciBlYWNoIHNlcnZlci1zaWRlIHJlbmRlciBjeWNsZS5cXG5cXG4tIEFyZSB5b3UgdHJ5aW5nIHRvIHJldXNlIGl0IGFjcm9zcyByZW5kZXJzP1xcbi0gQXJlIHlvdSBhY2NpZGVudGFsbHkgY2FsbGluZyBjb2xsZWN0U3R5bGVzIHR3aWNlP1xcblxcblwiLFxuICAgICczJzogJ1N0cmVhbWluZyBTU1IgaXMgb25seSBzdXBwb3J0ZWQgaW4gYSBOb2RlLmpzIGVudmlyb25tZW50OyBQbGVhc2UgZG8gbm90IHRyeSB0byBjYWxsIHRoaXMgbWV0aG9kIGluIHRoZSBicm93c2VyLlxcblxcbicsXG4gICAgJzQnOiAnVGhlIGBTdHlsZVNoZWV0TWFuYWdlcmAgZXhwZWN0cyBhIHZhbGlkIHRhcmdldCBvciBzaGVldCBwcm9wIVxcblxcbi0gRG9lcyB0aGlzIGVycm9yIG9jY3VyIG9uIHRoZSBjbGllbnQgYW5kIGlzIHlvdXIgdGFyZ2V0IGZhbHN5P1xcbi0gRG9lcyB0aGlzIGVycm9yIG9jY3VyIG9uIHRoZSBzZXJ2ZXIgYW5kIGlzIHRoZSBzaGVldCBmYWxzeT9cXG5cXG4nLFxuICAgICc1JzogJ1RoZSBjbG9uZSBtZXRob2QgY2Fubm90IGJlIHVzZWQgb24gdGhlIGNsaWVudCFcXG5cXG4tIEFyZSB5b3UgcnVubmluZyBpbiBhIGNsaWVudC1saWtlIGVudmlyb25tZW50IG9uIHRoZSBzZXJ2ZXI/XFxuLSBBcmUgeW91IHRyeWluZyB0byBydW4gU1NSIG9uIHRoZSBjbGllbnQ/XFxuXFxuJyxcbiAgICAnNic6IFwiVHJ5aW5nIHRvIGluc2VydCBhIG5ldyBzdHlsZSB0YWcsIGJ1dCB0aGUgZ2l2ZW4gTm9kZSBpcyB1bm1vdW50ZWQhXFxuXFxuLSBBcmUgeW91IHVzaW5nIGEgY3VzdG9tIHRhcmdldCB0aGF0IGlzbid0IG1vdW50ZWQ/XFxuLSBEb2VzIHlvdXIgZG9jdW1lbnQgbm90IGhhdmUgYSB2YWxpZCBoZWFkIGVsZW1lbnQ/XFxuLSBIYXZlIHlvdSBhY2NpZGVudGFsbHkgcmVtb3ZlZCBhIHN0eWxlIHRhZyBtYW51YWxseT9cXG5cXG5cIixcbiAgICAnNyc6ICdUaGVtZVByb3ZpZGVyOiBQbGVhc2UgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHlvdXIgXCJ0aGVtZVwiIHByb3AgZnVuY3Rpb24sIGUuZy5cXG5cXG5gYGBqc1xcbnRoZW1lPXsoKSA9PiAoe30pfVxcbmBgYFxcblxcbicsXG4gICAgJzgnOiAnVGhlbWVQcm92aWRlcjogUGxlYXNlIG1ha2UgeW91ciBcInRoZW1lXCIgcHJvcCBhbiBvYmplY3QuXFxuXFxuJyxcbiAgICAnOSc6ICdNaXNzaW5nIGRvY3VtZW50IGA8aGVhZD5gXFxuXFxuJyxcbiAgICAnMTAnOiAnQ2Fubm90IGZpbmQgYSBTdHlsZVNoZWV0IGluc3RhbmNlLiBVc3VhbGx5IHRoaXMgaGFwcGVucyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29waWVzIG9mIHN0eWxlZC1jb21wb25lbnRzIGxvYWRlZCBhdCBvbmNlLiBDaGVjayBvdXQgdGhpcyBpc3N1ZSBmb3IgaG93IHRvIHRyb3VibGVzaG9vdCBhbmQgZml4IHRoZSBjb21tb24gY2FzZXMgd2hlcmUgdGhpcyBzaXR1YXRpb24gY2FuIGhhcHBlbjogaHR0cHM6Ly9naXRodWIuY29tL3N0eWxlZC1jb21wb25lbnRzL3N0eWxlZC1jb21wb25lbnRzL2lzc3Vlcy8xOTQxI2lzc3VlY29tbWVudC00MTc4NjIwMjFcXG5cXG4nLFxuICAgICcxMSc6ICdfVGhpcyBlcnJvciB3YXMgcmVwbGFjZWQgd2l0aCBhIGRldi10aW1lIHdhcm5pbmcsIGl0IHdpbGwgYmUgZGVsZXRlZCBmb3IgdjQgZmluYWwuXyBbY3JlYXRlR2xvYmFsU3R5bGVdIHJlY2VpdmVkIGNoaWxkcmVuIHdoaWNoIHdpbGwgbm90IGJlIHJlbmRlcmVkLiBQbGVhc2UgdXNlIHRoZSBjb21wb25lbnQgd2l0aG91dCBwYXNzaW5nIGNoaWxkcmVuIGVsZW1lbnRzLlxcblxcbicsXG4gICAgJzEyJzogJ0l0IHNlZW1zIHlvdSBhcmUgaW50ZXJwb2xhdGluZyBhIGtleWZyYW1lIGRlY2xhcmF0aW9uICglcykgaW50byBhbiB1bnRhZ2dlZCBzdHJpbmcuIFRoaXMgd2FzIHN1cHBvcnRlZCBpbiBzdHlsZWQtY29tcG9uZW50cyB2MywgYnV0IGlzIG5vdCBsb25nZXIgc3VwcG9ydGVkIGluIHY0IGFzIGtleWZyYW1lcyBhcmUgbm93IGluamVjdGVkIG9uLWRlbWFuZC4gUGxlYXNlIHdyYXAgeW91ciBzdHJpbmcgaW4gdGhlIGNzc1xcXFxgXFxcXGAgaGVscGVyIHdoaWNoIGVuc3VyZXMgdGhlIHN0eWxlcyBhcmUgaW5qZWN0ZWQgY29ycmVjdGx5LiBTZWUgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYXBpI2Nzc1xcblxcbicsXG4gICAgJzEzJzogJyVzIGlzIG5vdCBhIHN0eWxlZCBjb21wb25lbnQgYW5kIGNhbm5vdCBiZSByZWZlcnJlZCB0byB2aWEgY29tcG9uZW50IHNlbGVjdG9yLiBTZWUgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYWR2YW5jZWQjcmVmZXJyaW5nLXRvLW90aGVyLWNvbXBvbmVudHMgZm9yIG1vcmUgZGV0YWlscy5cXG5cXG4nLFxuICAgICcxNCc6ICdUaGVtZVByb3ZpZGVyOiBcInRoZW1lXCIgcHJvcCBpcyByZXF1aXJlZC5cXG5cXG4nLFxuICAgICcxNSc6IFwiQSBzdHlsaXMgcGx1Z2luIGhhcyBiZWVuIHN1cHBsaWVkIHRoYXQgaXMgbm90IG5hbWVkLiBXZSBuZWVkIGEgbmFtZSBmb3IgZWFjaCBwbHVnaW4gdG8gYmUgYWJsZSB0byBwcmV2ZW50IHN0eWxpbmcgY29sbGlzaW9ucyBiZXR3ZWVuIGRpZmZlcmVudCBzdHlsaXMgY29uZmlndXJhdGlvbnMgd2l0aGluIHRoZSBzYW1lIGFwcC4gQmVmb3JlIHlvdSBwYXNzIHlvdXIgcGx1Z2luIHRvIGA8U3R5bGVTaGVldE1hbmFnZXIgc3R5bGlzUGx1Z2lucz17W119PmAsIHBsZWFzZSBtYWtlIHN1cmUgZWFjaCBwbHVnaW4gaXMgdW5pcXVlbHktbmFtZWQsIGUuZy5cXG5cXG5gYGBqc1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbXBvcnRlZFBsdWdpbiwgJ25hbWUnLCB7IHZhbHVlOiAnc29tZS11bmlxdWUtbmFtZScgfSk7XFxuYGBgXFxuXFxuXCIsXG4gICAgJzE2JzogXCJSZWFjaGVkIHRoZSBsaW1pdCBvZiBob3cgbWFueSBzdHlsZWQgY29tcG9uZW50cyBtYXkgYmUgY3JlYXRlZCBhdCBncm91cCAlcy5cXG5Zb3UgbWF5IG9ubHkgY3JlYXRlIHVwIHRvIDEsMDczLDc0MSw4MjQgY29tcG9uZW50cy4gSWYgeW91J3JlIGNyZWF0aW5nIGNvbXBvbmVudHMgZHluYW1pY2FsbHksXFxuYXMgZm9yIGluc3RhbmNlIGluIHlvdXIgcmVuZGVyIG1ldGhvZCB0aGVuIHlvdSBtYXkgYmUgcnVubmluZyBpbnRvIHRoaXMgbGltaXRhdGlvbi5cXG5cXG5cIixcbiAgICAnMTcnOiBcIkNTU1N0eWxlU2hlZXQgY291bGQgbm90IGJlIGZvdW5kIG9uIEhUTUxTdHlsZUVsZW1lbnQuXFxuSGFzIHN0eWxlZC1jb21wb25lbnRzJyBzdHlsZSB0YWcgYmVlbiB1bm1vdW50ZWQgb3IgYWx0ZXJlZCBieSBhbm90aGVyIHNjcmlwdD9cXG5cIixcbn07XG5cbnZhciBFUlJPUlMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gZXJyb3JNYXAgOiB7fTtcbi8qKlxuICogc3VwZXIgYmFzaWMgdmVyc2lvbiBvZiBzcHJpbnRmXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGEgPSBhcmdzWzBdO1xuICAgIHZhciBiID0gW107XG4gICAgZm9yICh2YXIgYyA9IDEsIGxlbiA9IGFyZ3MubGVuZ3RoOyBjIDwgbGVuOyBjICs9IDEpIHtcbiAgICAgICAgYi5wdXNoKGFyZ3NbY10pO1xuICAgIH1cbiAgICBiLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgYSA9IGEucmVwbGFjZSgvJVthLXpdLywgZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGE7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBlcnJvciBmaWxlIG91dCBvZiBlcnJvcnMubWQgZm9yIGRldmVsb3BtZW50IGFuZCBhIHNpbXBsZSB3ZWIgbGluayB0byB0aGUgZnVsbCBlcnJvcnNcbiAqIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAqL1xuZnVuY3Rpb24gdGhyb3dTdHlsZWRDb21wb25lbnRzRXJyb3IoY29kZSkge1xuICAgIHZhciBpbnRlcnBvbGF0aW9ucyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGludGVycG9sYXRpb25zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3R5bGVkLWNvbXBvbmVudHMvc3R5bGVkLWNvbXBvbmVudHMvYmxvYi9tYWluL3BhY2thZ2VzL3N0eWxlZC1jb21wb25lbnRzL3NyYy91dGlscy9lcnJvcnMubWQjXCIuY29uY2F0KGNvZGUsIFwiIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKS5jb25jYXQoaW50ZXJwb2xhdGlvbnMubGVuZ3RoID4gMCA/IFwiIEFyZ3M6IFwiLmNvbmNhdChpbnRlcnBvbGF0aW9ucy5qb2luKCcsICcpKSA6ICcnKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGZvcm1hdC5hcHBseSh2b2lkIDAsIHRzbGliLl9fc3ByZWFkQXJyYXkoW0VSUk9SU1tjb2RlXV0sIGludGVycG9sYXRpb25zLCBmYWxzZSkpLnRyaW0oKSk7XG4gICAgfVxufVxuXG4vKiogQ3JlYXRlIGEgR3JvdXBlZFRhZyB3aXRoIGFuIHVuZGVybHlpbmcgVGFnIGltcGxlbWVudGF0aW9uICovXG52YXIgbWFrZUdyb3VwZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgcmV0dXJuIG5ldyBEZWZhdWx0R3JvdXBlZFRhZyh0YWcpO1xufTtcbnZhciBCQVNFX1NJWkUgPSAxIDw8IDk7XG52YXIgRGVmYXVsdEdyb3VwZWRUYWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdEdyb3VwZWRUYWcodGFnKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBTaXplcyA9IG5ldyBVaW50MzJBcnJheShCQVNFX1NJWkUpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IEJBU0VfU0laRTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgfVxuICAgIERlZmF1bHRHcm91cGVkVGFnLnByb3RvdHlwZS5pbmRleE9mR3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cDsgaSsrKSB7XG4gICAgICAgICAgICBpbmRleCArPSB0aGlzLmdyb3VwU2l6ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgRGVmYXVsdEdyb3VwZWRUYWcucHJvdG90eXBlLmluc2VydFJ1bGVzID0gZnVuY3Rpb24gKGdyb3VwLCBydWxlcykge1xuICAgICAgICBpZiAoZ3JvdXAgPj0gdGhpcy5ncm91cFNpemVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG9sZEJ1ZmZlciA9IHRoaXMuZ3JvdXBTaXplcztcbiAgICAgICAgICAgIHZhciBvbGRTaXplID0gb2xkQnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBuZXdTaXplID0gb2xkU2l6ZTtcbiAgICAgICAgICAgIHdoaWxlIChncm91cCA+PSBuZXdTaXplKSB7XG4gICAgICAgICAgICAgICAgbmV3U2l6ZSA8PD0gMTtcbiAgICAgICAgICAgICAgICBpZiAobmV3U2l6ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhyb3dTdHlsZWRDb21wb25lbnRzRXJyb3IoMTYsIFwiXCIuY29uY2F0KGdyb3VwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ncm91cFNpemVzID0gbmV3IFVpbnQzMkFycmF5KG5ld1NpemUpO1xuICAgICAgICAgICAgdGhpcy5ncm91cFNpemVzLnNldChvbGRCdWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBuZXdTaXplO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG9sZFNpemU7IGkgPCBuZXdTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwU2l6ZXNbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBydWxlSW5kZXggPSB0aGlzLmluZGV4T2ZHcm91cChncm91cCArIDEpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShydWxlcykpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGFnLmluc2VydFJ1bGUocnVsZUluZGV4LCBydWxlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cFNpemVzW2dyb3VwXSsrO1xuICAgICAgICAgICAgICAgICAgICBydWxlSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy50YWcuaW5zZXJ0UnVsZShydWxlSW5kZXgsIHJ1bGVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBTaXplc1tncm91cF0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVmYXVsdEdyb3VwZWRUYWcucHJvdG90eXBlLmNsZWFyR3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgaWYgKGdyb3VwIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGhfMSA9IHRoaXMuZ3JvdXBTaXplc1tncm91cF07XG4gICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IHRoaXMuaW5kZXhPZkdyb3VwKGdyb3VwKTtcbiAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyBsZW5ndGhfMTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBTaXplc1tncm91cF0gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWcuZGVsZXRlUnVsZShzdGFydEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVmYXVsdEdyb3VwZWRUYWcucHJvdG90eXBlLmdldEdyb3VwID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIHZhciBjc3MgPSAnJztcbiAgICAgICAgaWYgKGdyb3VwID49IHRoaXMubGVuZ3RoIHx8IHRoaXMuZ3JvdXBTaXplc1tncm91cF0gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjc3M7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuZ3JvdXBTaXplc1tncm91cF07XG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gdGhpcy5pbmRleE9mR3JvdXAoZ3JvdXApO1xuICAgICAgICB2YXIgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgbGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGNzcyArPSBcIlwiLmNvbmNhdCh0aGlzLnRhZy5nZXRSdWxlKGkpKS5jb25jYXQoU1BMSVRURVIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjc3M7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdEdyb3VwZWRUYWc7XG59KCkpO1xuXG52YXIgTUFYX1NNSSA9IDEgPDwgKDMxIC0gMSk7XG52YXIgZ3JvdXBJRFJlZ2lzdGVyID0gbmV3IE1hcCgpO1xudmFyIHJldmVyc2VSZWdpc3RlciA9IG5ldyBNYXAoKTtcbnZhciBuZXh0RnJlZUdyb3VwID0gMTtcbnZhciBnZXRHcm91cEZvcklkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKGdyb3VwSURSZWdpc3Rlci5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybiBncm91cElEUmVnaXN0ZXIuZ2V0KGlkKTtcbiAgICB9XG4gICAgd2hpbGUgKHJldmVyc2VSZWdpc3Rlci5oYXMobmV4dEZyZWVHcm91cCkpIHtcbiAgICAgICAgbmV4dEZyZWVHcm91cCsrO1xuICAgIH1cbiAgICB2YXIgZ3JvdXAgPSBuZXh0RnJlZUdyb3VwKys7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKChncm91cCB8IDApIDwgMCB8fCBncm91cCA+IE1BWF9TTUkpKSB7XG4gICAgICAgIHRocm93IHRocm93U3R5bGVkQ29tcG9uZW50c0Vycm9yKDE2LCBcIlwiLmNvbmNhdChncm91cCkpO1xuICAgIH1cbiAgICBncm91cElEUmVnaXN0ZXIuc2V0KGlkLCBncm91cCk7XG4gICAgcmV2ZXJzZVJlZ2lzdGVyLnNldChncm91cCwgaWQpO1xuICAgIHJldHVybiBncm91cDtcbn07XG52YXIgZ2V0SWRGb3JHcm91cCA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgIHJldHVybiByZXZlcnNlUmVnaXN0ZXIuZ2V0KGdyb3VwKTtcbn07XG52YXIgc2V0R3JvdXBGb3JJZCA9IGZ1bmN0aW9uIChpZCwgZ3JvdXApIHtcbiAgICBncm91cElEUmVnaXN0ZXIuc2V0KGlkLCBncm91cCk7XG4gICAgcmV2ZXJzZVJlZ2lzdGVyLnNldChncm91cCwgaWQpO1xufTtcblxudmFyIFNFTEVDVE9SID0gXCJzdHlsZVtcIi5jb25jYXQoU0NfQVRUUiwgXCJdW1wiKS5jb25jYXQoU0NfQVRUUl9WRVJTSU9OLCBcIj1cXFwiXCIpLmNvbmNhdChTQ19WRVJTSU9OLCBcIlxcXCJdXCIpO1xudmFyIE1BUktFUl9SRSA9IG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KFNDX0FUVFIsIFwiXFxcXC5nKFxcXFxkKylcXFxcW2lkPVxcXCIoW1xcXFx3XFxcXGQtXSspXFxcIlxcXFxdLio/XFxcIihbXlxcXCJdKilcIikpO1xudmFyIG91dHB1dFNoZWV0ID0gZnVuY3Rpb24gKHNoZWV0KSB7XG4gICAgdmFyIHRhZyA9IHNoZWV0LmdldFRhZygpO1xuICAgIHZhciBsZW5ndGggPSB0YWcubGVuZ3RoO1xuICAgIHZhciBjc3MgPSAnJztcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICB2YXIgaWQgPSBnZXRJZEZvckdyb3VwKGdyb3VwKTtcbiAgICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICB2YXIgbmFtZXMgPSBzaGVldC5uYW1lcy5nZXQoaWQpO1xuICAgICAgICB2YXIgcnVsZXMgPSB0YWcuZ2V0R3JvdXAoZ3JvdXApO1xuICAgICAgICBpZiAobmFtZXMgPT09IHVuZGVmaW5lZCB8fCBydWxlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBcIlwiLmNvbmNhdChTQ19BVFRSLCBcIi5nXCIpLmNvbmNhdChncm91cCwgXCJbaWQ9XFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIl1cIik7XG4gICAgICAgIHZhciBjb250ZW50ID0gJyc7XG4gICAgICAgIGlmIChuYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ICs9IFwiXCIuY29uY2F0KG5hbWUsIFwiLFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1RFOiBJdCdzIGVhc2llciB0byBjb2xsZWN0IHJ1bGVzIGFuZCBoYXZlIHRoZSBtYXJrZXJcbiAgICAgICAgLy8gYWZ0ZXIgdGhlIGFjdHVhbCBydWxlcyB0byBzaW1wbGlmeSB0aGUgcmVoeWRyYXRpb25cbiAgICAgICAgY3NzICs9IFwiXCIuY29uY2F0KHJ1bGVzKS5jb25jYXQoc2VsZWN0b3IsIFwie2NvbnRlbnQ6XFxcIlwiKS5jb25jYXQoY29udGVudCwgXCJcXFwifVwiKS5jb25jYXQoU1BMSVRURVIpO1xuICAgIH07XG4gICAgZm9yICh2YXIgZ3JvdXAgPSAwOyBncm91cCA8IGxlbmd0aDsgZ3JvdXArKykge1xuICAgICAgICBfbG9vcF8xKGdyb3VwKTtcbiAgICB9XG4gICAgcmV0dXJuIGNzcztcbn07XG52YXIgcmVoeWRyYXRlTmFtZXNGcm9tQ29udGVudCA9IGZ1bmN0aW9uIChzaGVldCwgaWQsIGNvbnRlbnQpIHtcbiAgICB2YXIgbmFtZXMgPSBjb250ZW50LnNwbGl0KCcsJyk7XG4gICAgdmFyIG5hbWU7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGlmICgobmFtZSA9IG5hbWVzW2ldKSkge1xuICAgICAgICAgICAgc2hlZXQucmVnaXN0ZXJOYW1lKGlkLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG52YXIgcmVoeWRyYXRlU2hlZXRGcm9tVGFnID0gZnVuY3Rpb24gKHNoZWV0LCBzdHlsZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgcGFydHMgPSAoKF9hID0gc3R5bGUudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKS5zcGxpdChTUExJVFRFUik7XG4gICAgdmFyIHJ1bGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXS50cmltKCk7XG4gICAgICAgIGlmICghcGFydClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWFya2VyID0gcGFydC5tYXRjaChNQVJLRVJfUkUpO1xuICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBwYXJzZUludChtYXJrZXJbMV0sIDEwKSB8IDA7XG4gICAgICAgICAgICB2YXIgaWQgPSBtYXJrZXJbMl07XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBSZWh5ZHJhdGUgY29tcG9uZW50SWQgdG8gZ3JvdXAgaW5kZXggbWFwcGluZ1xuICAgICAgICAgICAgICAgIHNldEdyb3VwRm9ySWQoaWQsIGdyb3VwKTtcbiAgICAgICAgICAgICAgICAvLyBSZWh5ZHJhdGUgbmFtZXMgYW5kIHJ1bGVzXG4gICAgICAgICAgICAgICAgLy8gbG9va3MgbGlrZTogZGF0YS1zdHlsZWQuZzExW2lkPVwiaWRBXCJde2NvbnRlbnQ6XCJuYW1lQSxcIn1cbiAgICAgICAgICAgICAgICByZWh5ZHJhdGVOYW1lc0Zyb21Db250ZW50KHNoZWV0LCBpZCwgbWFya2VyWzNdKTtcbiAgICAgICAgICAgICAgICBzaGVldC5nZXRUYWcoKS5pbnNlcnRSdWxlcyhncm91cCwgcnVsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJ1bGVzLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xudmFyIHJlaHlkcmF0ZVNoZWV0ID0gZnVuY3Rpb24gKHNoZWV0KSB7XG4gICAgdmFyIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoU0NfQVRUUikgIT09IFNDX0FUVFJfQUNUSVZFKSB7XG4gICAgICAgICAgICByZWh5ZHJhdGVTaGVldEZyb21UYWcoc2hlZXQsIG5vZGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGdldE5vbmNlKCkge1xuICAgIHJldHVybiB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xufVxuXG52YXIgRUxFTUVOVF9UWVBFID0gMTtcbi8qIE5vZGUuRUxFTUVOVF9UWVBFICovXG4vKiogRmluZCBsYXN0IHN0eWxlIGVsZW1lbnQgaWYgYW55IGluc2lkZSB0YXJnZXQgKi9cbnZhciBmaW5kTGFzdFN0eWxlVGFnID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBjaGlsZE5vZGVzID0gdGFyZ2V0LmNoaWxkTm9kZXM7XG4gICAgZm9yICh2YXIgaSA9IGNoaWxkTm9kZXMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGQubm9kZVR5cGUgPT09IEVMRU1FTlRfVFlQRSAmJiBjaGlsZC5oYXNBdHRyaWJ1dGUoU0NfQVRUUikpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbi8qKiBDcmVhdGUgYSBzdHlsZSBlbGVtZW50IGluc2lkZSBgdGFyZ2V0YCBvciA8aGVhZD4gYWZ0ZXIgdGhlIGxhc3QgKi9cbnZhciBtYWtlU3R5bGVUYWcgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkO1xuICAgIHZhciBwYXJlbnQgPSB0YXJnZXQgfHwgaGVhZDtcbiAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHZhciBwcmV2U3R5bGUgPSBmaW5kTGFzdFN0eWxlVGFnKHBhcmVudCk7XG4gICAgdmFyIG5leHRTaWJsaW5nID0gcHJldlN0eWxlICE9PSB1bmRlZmluZWQgPyBwcmV2U3R5bGUubmV4dFNpYmxpbmcgOiBudWxsO1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShTQ19BVFRSLCBTQ19BVFRSX0FDVElWRSk7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKFNDX0FUVFJfVkVSU0lPTiwgU0NfVkVSU0lPTik7XG4gICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcbiAgICBpZiAobm9uY2UpXG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuICAgIHJldHVybiBzdHlsZTtcbn07XG4vKiogR2V0IHRoZSBDU1NTdHlsZVNoZWV0IGluc3RhbmNlIGZvciBhIGdpdmVuIHN0eWxlIGVsZW1lbnQgKi9cbnZhciBnZXRTaGVldCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICBpZiAodGFnLnNoZWV0KSB7XG4gICAgICAgIHJldHVybiB0YWcuc2hlZXQ7XG4gICAgfVxuICAgIC8vIEF2b2lkIEZpcmVmb3ggcXVpcmsgd2hlcmUgdGhlIHN0eWxlIGVsZW1lbnQgbWlnaHQgbm90IGhhdmUgYSBzaGVldCBwcm9wZXJ0eVxuICAgIHZhciBzdHlsZVNoZWV0cyA9IGRvY3VtZW50LnN0eWxlU2hlZXRzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3R5bGVTaGVldHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBzaGVldCA9IHN0eWxlU2hlZXRzW2ldO1xuICAgICAgICBpZiAoc2hlZXQub3duZXJOb2RlID09PSB0YWcpIHtcbiAgICAgICAgICAgIHJldHVybiBzaGVldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyB0aHJvd1N0eWxlZENvbXBvbmVudHNFcnJvcigxNyk7XG59O1xuXG4vKiogQ3JlYXRlIGEgQ1NTU3R5bGVTaGVldC1saWtlIHRhZyBkZXBlbmRpbmcgb24gdGhlIGVudmlyb25tZW50ICovXG52YXIgbWFrZVRhZyA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBpc1NlcnZlciA9IF9hLmlzU2VydmVyLCB1c2VDU1NPTUluamVjdGlvbiA9IF9hLnVzZUNTU09NSW5qZWN0aW9uLCB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgaWYgKGlzU2VydmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlydHVhbFRhZyh0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh1c2VDU1NPTUluamVjdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IENTU09NVGFnKHRhcmdldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRUYWcodGFyZ2V0KTtcbiAgICB9XG59O1xudmFyIENTU09NVGFnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENTU09NVGFnKHRhcmdldCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICh0aGlzLmVsZW1lbnQgPSBtYWtlU3R5bGVUYWcodGFyZ2V0KSk7XG4gICAgICAgIC8vIEF2b2lkIEVkZ2UgYnVnIHdoZXJlIGVtcHR5IHN0eWxlIGVsZW1lbnRzIGRvbid0IGNyZWF0ZSBzaGVldHNcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJykpO1xuICAgICAgICB0aGlzLnNoZWV0ID0gZ2V0U2hlZXQoZWxlbWVudCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgQ1NTT01UYWcucHJvdG90eXBlLmluc2VydFJ1bGUgPSBmdW5jdGlvbiAoaW5kZXgsIHJ1bGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc2hlZXQuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDU1NPTVRhZy5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLnNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH07XG4gICAgQ1NTT01UYWcucHJvdG90eXBlLmdldFJ1bGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLnNoZWV0LmNzc1J1bGVzW2luZGV4XTtcbiAgICAgICAgLy8gQXZvaWQgSUUxMSBxdWlyayB3aGVyZSBjc3NUZXh0IGlzIGluYWNjZXNzaWJsZSBvbiBzb21lIGludmFsaWQgcnVsZXNcbiAgICAgICAgaWYgKHJ1bGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcnVsZS5jc3NUZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bGUuY3NzVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENTU09NVGFnO1xufSgpKTtcbi8qKiBBIFRhZyB0aGF0IGVtdWxhdGVzIHRoZSBDU1NTdHlsZVNoZWV0IEFQSSBidXQgdXNlcyB0ZXh0IG5vZGVzICovXG52YXIgVGV4dFRhZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0VGFnKHRhcmdldCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICh0aGlzLmVsZW1lbnQgPSBtYWtlU3R5bGVUYWcodGFyZ2V0KSk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBlbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgVGV4dFRhZy5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIChpbmRleCwgcnVsZSkge1xuICAgICAgICBpZiAoaW5kZXggPD0gdGhpcy5sZW5ndGggJiYgaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShydWxlKTtcbiAgICAgICAgICAgIHZhciByZWZOb2RlID0gdGhpcy5ub2Rlc1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZk5vZGUgfHwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRUYWcucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMubm9kZXNbaW5kZXhdKTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICB9O1xuICAgIFRleHRUYWcucHJvdG90eXBlLmdldFJ1bGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzW2luZGV4XS50ZXh0Q29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRleHRUYWc7XG59KCkpO1xuLyoqIEEgY29tcGxldGVseSB2aXJ0dWFsIChzZXJ2ZXItc2lkZSkgVGFnIHRoYXQgZG9lc24ndCBtYW5pcHVsYXRlIHRoZSBET00gKi9cbnZhciBWaXJ0dWFsVGFnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpcnR1YWxUYWcoX3RhcmdldCkge1xuICAgICAgICB0aGlzLnJ1bGVzID0gW107XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgVmlydHVhbFRhZy5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIChpbmRleCwgcnVsZSkge1xuICAgICAgICBpZiAoaW5kZXggPD0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucnVsZXMuc3BsaWNlKGluZGV4LCAwLCBydWxlKTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlydHVhbFRhZy5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLnJ1bGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgfTtcbiAgICBWaXJ0dWFsVGFnLnByb3RvdHlwZS5nZXRSdWxlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydWxlc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBWaXJ0dWFsVGFnO1xufSgpKTtcblxudmFyIFNIT1VMRF9SRUhZRFJBVEUgPSBJU19CUk9XU0VSO1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGlzU2VydmVyOiAhSVNfQlJPV1NFUixcbiAgICB1c2VDU1NPTUluamVjdGlvbjogIURJU0FCTEVfU1BFRURZLFxufTtcbi8qKiBDb250YWlucyB0aGUgbWFpbiBzdHlsZXNoZWV0IGxvZ2ljIGZvciBzdHJpbmdpZmljYXRpb24gYW5kIGNhY2hpbmcgKi9cbnZhciBTdHlsZVNoZWV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlU2hlZXQob3B0aW9ucywgZ2xvYmFsU3R5bGVzLCBuYW1lcykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBFTVBUWV9PQkpFQ1Q7IH1cbiAgICAgICAgaWYgKGdsb2JhbFN0eWxlcyA9PT0gdm9pZCAwKSB7IGdsb2JhbFN0eWxlcyA9IHt9OyB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdzID0gZ2xvYmFsU3R5bGVzO1xuICAgICAgICB0aGlzLm5hbWVzID0gbmV3IE1hcChuYW1lcyk7XG4gICAgICAgIHRoaXMuc2VydmVyID0gISFvcHRpb25zLmlzU2VydmVyO1xuICAgICAgICAvLyBXZSByZWh5ZHJhdGUgb25seSBvbmNlIGFuZCB1c2UgdGhlIHNoZWV0IHRoYXQgaXMgY3JlYXRlZCBmaXJzdFxuICAgICAgICBpZiAoIXRoaXMuc2VydmVyICYmIElTX0JST1dTRVIgJiYgU0hPVUxEX1JFSFlEUkFURSkge1xuICAgICAgICAgICAgU0hPVUxEX1JFSFlEUkFURSA9IGZhbHNlO1xuICAgICAgICAgICAgcmVoeWRyYXRlU2hlZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVyIGEgZ3JvdXAgSUQgdG8gZ2l2ZSBpdCBhbiBpbmRleCAqL1xuICAgIFN0eWxlU2hlZXQucmVnaXN0ZXJJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gZ2V0R3JvdXBGb3JJZChpZCk7XG4gICAgfTtcbiAgICBTdHlsZVNoZWV0LnByb3RvdHlwZS5yZWNvbnN0cnVjdFdpdGhPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIHdpdGhOYW1lcykge1xuICAgICAgICBpZiAod2l0aE5hbWVzID09PSB2b2lkIDApIHsgd2l0aE5hbWVzID0gdHJ1ZTsgfVxuICAgICAgICByZXR1cm4gbmV3IFN0eWxlU2hlZXQodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpLCB0aGlzLmdzLCAod2l0aE5hbWVzICYmIHRoaXMubmFtZXMpIHx8IHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBTdHlsZVNoZWV0LnByb3RvdHlwZS5hbGxvY2F0ZUdTSW5zdGFuY2UgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdzW2lkXSA9ICh0aGlzLmdzW2lkXSB8fCAwKSArIDEpO1xuICAgIH07XG4gICAgLyoqIExhemlseSBpbml0aWFsaXNlcyBhIEdyb3VwZWRUYWcgZm9yIHdoZW4gaXQncyBhY3R1YWxseSBuZWVkZWQgKi9cbiAgICBTdHlsZVNoZWV0LnByb3RvdHlwZS5nZXRUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZyB8fCAodGhpcy50YWcgPSBtYWtlR3JvdXBlZFRhZyhtYWtlVGFnKHRoaXMub3B0aW9ucykpKTtcbiAgICB9O1xuICAgIC8qKiBDaGVjayB3aGV0aGVyIGEgbmFtZSBpcyBrbm93biBmb3IgY2FjaGluZyAqL1xuICAgIFN0eWxlU2hlZXQucHJvdG90eXBlLmhhc05hbWVGb3JJZCA9IGZ1bmN0aW9uIChpZCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lcy5oYXMoaWQpICYmIHRoaXMubmFtZXMuZ2V0KGlkKS5oYXMobmFtZSk7XG4gICAgfTtcbiAgICAvKiogTWFyayBhIGdyb3VwJ3MgbmFtZSBhcyBrbm93biBmb3IgY2FjaGluZyAqL1xuICAgIFN0eWxlU2hlZXQucHJvdG90eXBlLnJlZ2lzdGVyTmFtZSA9IGZ1bmN0aW9uIChpZCwgbmFtZSkge1xuICAgICAgICBnZXRHcm91cEZvcklkKGlkKTtcbiAgICAgICAgaWYgKCF0aGlzLm5hbWVzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHZhciBncm91cE5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZ3JvdXBOYW1lcy5hZGQobmFtZSk7XG4gICAgICAgICAgICB0aGlzLm5hbWVzLnNldChpZCwgZ3JvdXBOYW1lcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5hbWVzLmdldChpZCkuYWRkKG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogSW5zZXJ0IG5ldyBydWxlcyB3aGljaCBhbHNvIG1hcmtzIHRoZSBuYW1lIGFzIGtub3duICovXG4gICAgU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZXMgPSBmdW5jdGlvbiAoaWQsIG5hbWUsIHJ1bGVzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJOYW1lKGlkLCBuYW1lKTtcbiAgICAgICAgdGhpcy5nZXRUYWcoKS5pbnNlcnRSdWxlcyhnZXRHcm91cEZvcklkKGlkKSwgcnVsZXMpO1xuICAgIH07XG4gICAgLyoqIENsZWFycyBhbGwgY2FjaGVkIG5hbWVzIGZvciBhIGdpdmVuIGdyb3VwIElEICovXG4gICAgU3R5bGVTaGVldC5wcm90b3R5cGUuY2xlYXJOYW1lcyA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAodGhpcy5uYW1lcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWVzLmdldChpZCkuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIENsZWFycyBhbGwgcnVsZXMgZm9yIGEgZ2l2ZW4gZ3JvdXAgSUQgKi9cbiAgICBTdHlsZVNoZWV0LnByb3RvdHlwZS5jbGVhclJ1bGVzID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHRoaXMuZ2V0VGFnKCkuY2xlYXJHcm91cChnZXRHcm91cEZvcklkKGlkKSk7XG4gICAgICAgIHRoaXMuY2xlYXJOYW1lcyhpZCk7XG4gICAgfTtcbiAgICAvKiogQ2xlYXJzIHRoZSBlbnRpcmUgdGFnIHdoaWNoIGRlbGV0ZXMgYWxsIHJ1bGVzIGJ1dCBub3QgaXRzIG5hbWVzICovXG4gICAgU3R5bGVTaGVldC5wcm90b3R5cGUuY2xlYXJUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgZG9lcyBub3QgY2xlYXIgdGhlIG5hbWVzLCBzaW5jZSBpdCdzIG9ubHkgdXNlZCBkdXJpbmcgU1NSXG4gICAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBvdXRwdXQgb25seSBuZXcgcnVsZXNcbiAgICAgICAgdGhpcy50YWcgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKiogT3V0cHV0cyB0aGUgY3VycmVudCBzaGVldCBhcyBhIENTUyBzdHJpbmcgd2l0aCBtYXJrZXJzIGZvciBTU1IgKi9cbiAgICBTdHlsZVNoZWV0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dFNoZWV0KHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCkpO1xuXG52YXIgQ09NTUVOVF9SRUdFWCA9IC9eXFxzKlxcL1xcLy4qJC9nbTtcbnZhciBDT01QTEVYX1NFTEVDVE9SX1BSRUZJWCA9IFsnOicsICdbJywgJy4nLCAnIyddO1xuLyoqXG4gKiBTZXJpYWxpemUgc3R5bGlzIG91dHB1dCBhcyBhbiBhcnJheSBvZiBjc3Mgc3RyaW5ncy4gSXQgaXMgaW1wb3J0YW50IHRoYXQgcnVsZXMgYXJlXG4gKiBzZXBhcmF0ZWQgd2hlbiB1c2luZyBDU1NPTSBpbmplY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZShjaGlsZHJlbiwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjLCBpKSB7IHJldHVybiBjYWxsYmFjayhjLCBpLCBjaGlsZHJlbiwgY2FsbGJhY2spOyB9KS5maWx0ZXIoQm9vbGVhbik7XG59XG5mdW5jdGlvbiBjcmVhdGVTdHlsaXNJbnN0YW5jZShfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyBFTVBUWV9PQkpFQ1QgOiBfYSwgX2MgPSBfYi5vcHRpb25zLCBvcHRpb25zID0gX2MgPT09IHZvaWQgMCA/IEVNUFRZX09CSkVDVCA6IF9jLCBfZCA9IF9iLnBsdWdpbnMsIHBsdWdpbnMgPSBfZCA9PT0gdm9pZCAwID8gRU1QVFlfQVJSQVkgOiBfZDtcbiAgICB2YXIgX2NvbXBvbmVudElkO1xuICAgIHZhciBfc2VsZWN0b3I7XG4gICAgdmFyIF9zZWxlY3RvclJlZ2V4cDtcbiAgICB2YXIgX2NvbnNlY3V0aXZlU2VsZlJlZlJlZ0V4cDtcbiAgICB2YXIgc2VsZlJlZmVyZW5jZVJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoLCBvZmZzZXQsIHN0cmluZykge1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIGRvIG5vdCByZXBsYWNlIHRoZSBmaXJzdCBvY2N1cnJlbmNlIGlmIGl0IGlzIGNvbXBsZXggKGhhcyBhIG1vZGlmaWVyKVxuICAgICAgICAob2Zmc2V0ID09PSAwID8gIUNPTVBMRVhfU0VMRUNUT1JfUFJFRklYLmluY2x1ZGVzKHN0cmluZ1tfc2VsZWN0b3IubGVuZ3RoXSkgOiB0cnVlKSAmJiAvLyBubyBjb25zZWN1dGl2ZSBzZWxmIHJlZnMgKC5iLmIpOyB0aGF0IGlzIGEgcHJlY2VkZW5jZSBib29zdCBhbmQgdHJlYXRlZCBkaWZmZXJlbnRseVxuICAgICAgICAgICAgIXN0cmluZy5tYXRjaChfY29uc2VjdXRpdmVTZWxmUmVmUmVnRXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiLlwiLmNvbmNhdChfY29tcG9uZW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gd3JpdGluZyBhIHN0eWxlIGxpa2VcbiAgICAgKlxuICAgICAqICYgKyAmIHtcbiAgICAgKiAgIGNvbG9yOiByZWQ7XG4gICAgICogfVxuICAgICAqXG4gICAgICogVGhlIHNlY29uZCBhbXBlcnNhbmQgc2hvdWxkIGJlIGEgcmVmZXJlbmNlIHRvIHRoZSBzdGF0aWMgY29tcG9uZW50IGNsYXNzLiBzdHlsaXNcbiAgICAgKiBoYXMgbm8ga25vd2xlZGdlIG9mIHN0YXRpYyBjbGFzcyBzbyB3ZSBoYXZlIHRvIGludGVsbGlnZW50bHkgcmVwbGFjZSB0aGUgYmFzZSBzZWxlY3Rvci5cbiAgICAgKlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90aHlzdWx0YW4vc3R5bGlzLmpzL3RyZWUvdjQuMC4yI2Fic3RyYWN0LXN5bnRheC1zdHJ1Y3R1cmVcbiAgICAgKi9cbiAgICB2YXIgc2VsZlJlZmVyZW5jZVJlcGxhY2VtZW50UGx1Z2luID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gc3R5bGlzLlJVTEVTRVQgJiYgZWxlbWVudC52YWx1ZS5pbmNsdWRlcygnJicpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICAgICAgICAgICAgcHJvcHNbMF0gPSBwcm9wc1swXS5yZXBsYWNlKF9zZWxlY3RvclJlZ2V4cCwgc2VsZlJlZmVyZW5jZVJlcGxhY2VyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0cmluZ2lmeVJ1bGVzID0gZnVuY3Rpb24gKGNzcywgc2VsZWN0b3IsIFxuICAgIC8qKlxuICAgICAqIFRoaXMgXCJwcmVmaXhcIiByZWZlcmVzIHRvIGEgX3NlbGVjdG9yXyBwcmVmaXguXG4gICAgICovXG4gICAgcHJlZml4LCBjb21wb25lbnRJZCkge1xuICAgICAgICBpZiAoc2VsZWN0b3IgPT09IHZvaWQgMCkgeyBzZWxlY3RvciA9ICcnOyB9XG4gICAgICAgIGlmIChwcmVmaXggPT09IHZvaWQgMCkgeyBwcmVmaXggPSAnJzsgfVxuICAgICAgICBpZiAoY29tcG9uZW50SWQgPT09IHZvaWQgMCkgeyBjb21wb25lbnRJZCA9ICcmJzsgfVxuICAgICAgICB2YXIgZmxhdENTUyA9IGNzcy5yZXBsYWNlKENPTU1FTlRfUkVHRVgsICcnKTtcbiAgICAgICAgLy8gc3R5bGlzIGhhcyBubyBjb25jZXB0IG9mIHN0YXRlIHRvIGJlIHBhc3NlZCB0byBwbHVnaW5zXG4gICAgICAgIC8vIGJ1dCBzaW5jZSBKUyBpcyBzaW5nbGUtdGhyZWFkZWQsIHdlIGNhbiByZWx5IG9uIHRoYXQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoZXNlIHByb3BlcnRpZXMgc3RheSBpbiBzeW5jIHdpdGggdGhlIGN1cnJlbnQgc3R5bGlzIHJ1blxuICAgICAgICBfY29tcG9uZW50SWQgPSBjb21wb25lbnRJZDtcbiAgICAgICAgX3NlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIF9zZWxlY3RvclJlZ2V4cCA9IG5ldyBSZWdFeHAoXCJcXFxcXCIuY29uY2F0KF9zZWxlY3RvciwgXCJcXFxcYlwiKSwgJ2cnKTtcbiAgICAgICAgX2NvbnNlY3V0aXZlU2VsZlJlZlJlZ0V4cCA9IG5ldyBSZWdFeHAoXCIoXFxcXFwiLmNvbmNhdChfc2VsZWN0b3IsIFwiXFxcXGIpezIsfVwiKSk7XG4gICAgICAgIHZhciBtaWRkbGV3YXJlcyA9IHBsdWdpbnMuc2xpY2UoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgYXV0b21hdGljIHZlbmRvci1wcmVmaXhpbmcgZm9yIHN0eWxlcy5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChvcHRpb25zLnByZWZpeCB8fCBvcHRpb25zLnByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtaWRkbGV3YXJlcy51bnNoaWZ0KHN0eWxpcy5wcmVmaXhlcik7XG4gICAgICAgIH1cbiAgICAgICAgbWlkZGxld2FyZXMucHVzaChzZWxmUmVmZXJlbmNlUmVwbGFjZW1lbnRQbHVnaW4sIHN0eWxpcy5zdHJpbmdpZnkpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplKHN0eWxpcy5jb21waWxlKG9wdGlvbnMubmFtZXNwYWNlIHx8IHByZWZpeCB8fCBzZWxlY3RvclxuICAgICAgICAgICAgPyBcIlwiLmNvbmNhdChvcHRpb25zLm5hbWVzcGFjZSA/IG9wdGlvbnMubmFtZXNwYWNlICsgJyAnIDogJycpLmNvbmNhdChwcmVmaXgsIFwiIFwiKS5jb25jYXQoc2VsZWN0b3IsIFwiIHsgXCIpLmNvbmNhdChmbGF0Q1NTLCBcIiB9XCIpXG4gICAgICAgICAgICA6IGZsYXRDU1MpLCBzdHlsaXMubWlkZGxld2FyZShtaWRkbGV3YXJlcykpO1xuICAgIH07XG4gICAgc3RyaW5naWZ5UnVsZXMuaGFzaCA9IHBsdWdpbnMubGVuZ3RoXG4gICAgICAgID8gcGx1Z2luc1xuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbHVnaW4pIHtcbiAgICAgICAgICAgIGlmICghcGx1Z2luLm5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1N0eWxlZENvbXBvbmVudHNFcnJvcigxNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGhhc2goYWNjLCBwbHVnaW4ubmFtZSk7XG4gICAgICAgIH0sIFNFRUQkMSlcbiAgICAgICAgICAgIC50b1N0cmluZygpXG4gICAgICAgIDogJyc7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVJ1bGVzO1xufVxuXG52YXIgU3R5bGVTaGVldENvbnRleHQgPSBSZWFjdF9fZGVmYXVsdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbnZhciBTdHlsZVNoZWV0Q29uc3VtZXIgPSBTdHlsZVNoZWV0Q29udGV4dC5Db25zdW1lcjtcbnZhciBTdHlsaXNDb250ZXh0ID0gUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5TdHlsaXNDb250ZXh0LkNvbnN1bWVyO1xudmFyIG1haW5TaGVldCA9IG5ldyBTdHlsZVNoZWV0KCk7XG52YXIgbWFpblN0eWxpcyA9IGNyZWF0ZVN0eWxpc0luc3RhbmNlKCk7XG5mdW5jdGlvbiB1c2VTdHlsZVNoZWV0KCkge1xuICAgIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFN0eWxlU2hlZXRDb250ZXh0KSB8fCBtYWluU2hlZXQ7XG59XG5mdW5jdGlvbiB1c2VTdHlsaXMoKSB7XG4gICAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoU3R5bGlzQ29udGV4dCkgfHwgbWFpblN0eWxpcztcbn1cbmZ1bmN0aW9uIFN0eWxlU2hlZXRNYW5hZ2VyKHByb3BzKSB7XG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUocHJvcHMuc3R5bGlzUGx1Z2lucyksIHBsdWdpbnMgPSBfYVswXSwgc2V0UGx1Z2lucyA9IF9hWzFdO1xuICAgIHZhciBjb250ZXh0U3R5bGVTaGVldCA9IHVzZVN0eWxlU2hlZXQoKTtcbiAgICB2YXIgc3R5bGVTaGVldCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2hlZXQgPSBjb250ZXh0U3R5bGVTaGVldDtcbiAgICAgICAgaWYgKHByb3BzLnNoZWV0KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgIHNoZWV0ID0gcHJvcHMuc2hlZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvcHMudGFyZ2V0KSB7XG4gICAgICAgICAgICBzaGVldCA9IHNoZWV0LnJlY29uc3RydWN0V2l0aE9wdGlvbnMoeyB0YXJnZXQ6IHByb3BzLnRhcmdldCB9LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmRpc2FibGVDU1NPTUluamVjdGlvbikge1xuICAgICAgICAgICAgc2hlZXQgPSBzaGVldC5yZWNvbnN0cnVjdFdpdGhPcHRpb25zKHsgdXNlQ1NTT01JbmplY3Rpb246IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGVldDtcbiAgICB9LCBbcHJvcHMuZGlzYWJsZUNTU09NSW5qZWN0aW9uLCBwcm9wcy5zaGVldCwgcHJvcHMudGFyZ2V0XSk7XG4gICAgdmFyIHN0eWxpcyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU3R5bGlzSW5zdGFuY2Uoe1xuICAgICAgICAgICAgb3B0aW9uczogeyBuYW1lc3BhY2U6IHByb3BzLm5hbWVzcGFjZSwgcHJlZml4OiAhcHJvcHMuZGlzYWJsZVZlbmRvclByZWZpeGVzIH0sXG4gICAgICAgICAgICBwbHVnaW5zOiBwbHVnaW5zLFxuICAgICAgICB9KTtcbiAgICB9LCBbcHJvcHMuZGlzYWJsZVZlbmRvclByZWZpeGVzLCBwcm9wcy5uYW1lc3BhY2UsIHBsdWdpbnNdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNoYWxsb3dlcXVhbF9fZGVmYXVsdC5kZWZhdWx0KHBsdWdpbnMsIHByb3BzLnN0eWxpc1BsdWdpbnMpKVxuICAgICAgICAgICAgc2V0UGx1Z2lucyhwcm9wcy5zdHlsaXNQbHVnaW5zKTtcbiAgICB9LCBbcHJvcHMuc3R5bGlzUGx1Z2luc10pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlU2hlZXRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzdHlsZVNoZWV0IH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsaXNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzdHlsaXMgfSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgPyBSZWFjdF9fZGVmYXVsdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkocHJvcHMuY2hpbGRyZW4pXG4gICAgICAgICAgICA6IHByb3BzLmNoaWxkcmVuKSkpO1xufVxuXG52YXIgS2V5ZnJhbWVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtleWZyYW1lcyhuYW1lLCBydWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmluamVjdCA9IGZ1bmN0aW9uIChzdHlsZVNoZWV0LCBzdHlsaXNJbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKHN0eWxpc0luc3RhbmNlID09PSB2b2lkIDApIHsgc3R5bGlzSW5zdGFuY2UgPSBtYWluU3R5bGlzOyB9XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZWROYW1lID0gX3RoaXMubmFtZSArIHN0eWxpc0luc3RhbmNlLmhhc2g7XG4gICAgICAgICAgICBpZiAoIXN0eWxlU2hlZXQuaGFzTmFtZUZvcklkKF90aGlzLmlkLCByZXNvbHZlZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlcyhfdGhpcy5pZCwgcmVzb2x2ZWROYW1lLCBzdHlsaXNJbnN0YW5jZShfdGhpcy5ydWxlcywgcmVzb2x2ZWROYW1lLCAnQGtleWZyYW1lcycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHRocm93U3R5bGVkQ29tcG9uZW50c0Vycm9yKDEyLCBTdHJpbmcoX3RoaXMubmFtZSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmlkID0gXCJzYy1rZXlmcmFtZXMtXCIuY29uY2F0KG5hbWUpO1xuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgfVxuICAgIEtleWZyYW1lcy5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uIChzdHlsaXNJbnN0YW5jZSkge1xuICAgICAgICBpZiAoc3R5bGlzSW5zdGFuY2UgPT09IHZvaWQgMCkgeyBzdHlsaXNJbnN0YW5jZSA9IG1haW5TdHlsaXM7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIHN0eWxpc0luc3RhbmNlLmhhc2g7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5ZnJhbWVzO1xufSgpKTtcblxuLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iODdhYWJkZmUxYjc0NjFlNzMzMWFiYjM2MDFkOWU2YmIyNzU0NGJjL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL2Rhbmdlcm91c1N0eWxlVmFsdWUuanNcbmZ1bmN0aW9uIGFkZFVuaXRJZk5lZWRlZChuYW1lLCB2YWx1ZSkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWlsYWphY2svZXNsaW50LXBsdWdpbi1mbG93dHlwZS1lcnJvcnMvaXNzdWVzLzEzM1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEobmFtZSBpbiB1bml0bGVzc19fZGVmYXVsdC5kZWZhdWx0KSkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodmFsdWUsIFwicHhcIik7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcodmFsdWUpLnRyaW0oKTtcbn1cblxuLyoqXG4gKiBpbmxpbmVkIHZlcnNpb24gb2ZcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL2ZianMvc3JjL2NvcmUvaHlwaGVuYXRlU3R5bGVOYW1lLmpzXG4gKi9cbnZhciB1cHBlcmNhc2VDaGVjayA9IC9bQS1aXS87XG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC9bQS1aXS9nO1xudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcbnZhciBwcmVmaXhBbmRMb3dlckNhc2UgPSBmdW5jdGlvbiAoY2hhcikgeyByZXR1cm4gXCItXCIuY29uY2F0KGNoYXIudG9Mb3dlckNhc2UoKSk7IH07XG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICAgIHJldHVybiB1cHBlcmNhc2VDaGVjay50ZXN0KHN0cmluZykgJiYgIXN0cmluZy5zdGFydHNXaXRoKCctLScpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgcHJlZml4QW5kTG93ZXJDYXNlKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKVxuICAgICAgICA6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih0ZXN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0ZXN0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc1N0YXRlbGVzc0Z1bmN0aW9uKHRlc3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbicgJiYgISh0ZXN0LnByb3RvdHlwZSAmJiB0ZXN0LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuLyoqXG4gKiBJdCdzIGZhbHNpc2ggbm90IGZhbHN5IGJlY2F1c2UgMCBpcyBhbGxvd2VkLlxuICovXG52YXIgaXNGYWxzaXNoID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgcmV0dXJuIGNodW5rID09PSB1bmRlZmluZWQgfHwgY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IGZhbHNlIHx8IGNodW5rID09PSAnJztcbn07XG52YXIgb2JqVG9Dc3NBcnJheSA9IGZ1bmN0aW9uIChvYmosIHByZXZLZXkpIHtcbiAgICB2YXIgcnVsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkgfHwgaXNGYWxzaXNoKG9ialtrZXldKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoKEFycmF5LmlzQXJyYXkob2JqW2tleV0pICYmIG9ialtrZXldLmlzQ3NzKSB8fCBpc0Z1bmN0aW9uKG9ialtrZXldKSkge1xuICAgICAgICAgICAgcnVsZXMucHVzaChcIlwiLmNvbmNhdChoeXBoZW5hdGVTdHlsZU5hbWUoa2V5KSwgXCI6XCIpLCBvYmpba2V5XSwgJzsnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KG9ialtrZXldKSkge1xuICAgICAgICAgICAgcnVsZXMucHVzaC5hcHBseShydWxlcywgb2JqVG9Dc3NBcnJheShvYmpba2V5XSwga2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBydWxlcy5wdXNoKFwiXCIuY29uY2F0KGh5cGhlbmF0ZVN0eWxlTmFtZShrZXkpLCBcIjogXCIpLmNvbmNhdChhZGRVbml0SWZOZWVkZWQoa2V5LCBvYmpba2V5XSksIFwiO1wiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByZXZLZXkgPyB0c2xpYi5fX3NwcmVhZEFycmF5KHRzbGliLl9fc3ByZWFkQXJyYXkoW1wiXCIuY29uY2F0KHByZXZLZXksIFwiIHtcIildLCBydWxlcywgdHJ1ZSksIFsnfSddLCBmYWxzZSkgOiBydWxlcztcbn07XG5mdW5jdGlvbiBmbGF0dGVuKGNodW5rLCBleGVjdXRpb25Db250ZXh0LCBzdHlsZVNoZWV0LCBzdHlsaXNJbnN0YW5jZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNodW5rKSkge1xuICAgICAgICB2YXIgcnVsZVNldCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2h1bmsubGVuZ3RoLCByZXN1bHQgPSB2b2lkIDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmxhdHRlbihjaHVua1tpXSwgZXhlY3V0aW9uQ29udGV4dCwgc3R5bGVTaGVldCwgc3R5bGlzSW5zdGFuY2UpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBydWxlU2V0LnB1c2guYXBwbHkocnVsZVNldCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZVNldDtcbiAgICB9XG4gICAgaWYgKGlzRmFsc2lzaChjaHVuaykpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKiBIYW5kbGUgb3RoZXIgY29tcG9uZW50cyAqL1xuICAgIGlmIChpc1N0eWxlZENvbXBvbmVudChjaHVuaykpIHtcbiAgICAgICAgcmV0dXJuIFtcIi5cIi5jb25jYXQoY2h1bmsuc3R5bGVkQ29tcG9uZW50SWQpXTtcbiAgICB9XG4gICAgLyogRWl0aGVyIGV4ZWN1dGUgb3IgZGVmZXIgdGhlIGZ1bmN0aW9uICovXG4gICAgaWYgKGlzRnVuY3Rpb24oY2h1bmspKSB7XG4gICAgICAgIGlmIChpc1N0YXRlbGVzc0Z1bmN0aW9uKGNodW5rKSAmJiBleGVjdXRpb25Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY2h1bmtGbiA9IGNodW5rO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNodW5rRm4oZXhlY3V0aW9uQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkocmVzdWx0KSAmJlxuICAgICAgICAgICAgICAgICEocmVzdWx0IGluc3RhbmNlb2YgS2V5ZnJhbWVzKSAmJlxuICAgICAgICAgICAgICAgICFpc1BsYWluT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQoZ2V0Q29tcG9uZW50TmFtZShjaHVua0ZuKSwgXCIgaXMgbm90IGEgc3R5bGVkIGNvbXBvbmVudCBhbmQgY2Fubm90IGJlIHJlZmVycmVkIHRvIHZpYSBjb21wb25lbnQgc2VsZWN0b3IuIFNlZSBodHRwczovL3d3dy5zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9hZHZhbmNlZCNyZWZlcnJpbmctdG8tb3RoZXItY29tcG9uZW50cyBmb3IgbW9yZSBkZXRhaWxzLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlbihyZXN1bHQsIGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQsIHN0eWxpc0luc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbY2h1bmtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIEtleWZyYW1lcykge1xuICAgICAgICBpZiAoc3R5bGVTaGVldCkge1xuICAgICAgICAgICAgY2h1bmsuaW5qZWN0KHN0eWxlU2hlZXQsIHN0eWxpc0luc3RhbmNlKTtcbiAgICAgICAgICAgIHJldHVybiBbY2h1bmsuZ2V0TmFtZShzdHlsaXNJbnN0YW5jZSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtjaHVua107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogSGFuZGxlIG9iamVjdHMgKi9cbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdChjaHVuaykgPyBvYmpUb0Nzc0FycmF5KGNodW5rKSA6IFtjaHVuay50b1N0cmluZygpXTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNSdWxlcyhydWxlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocnVsZSkgJiYgIWlzU3R5bGVkQ29tcG9uZW50KHJ1bGUpKSB7XG4gICAgICAgICAgICAvLyBmdW5jdGlvbnMgYXJlIGFsbG93ZWQgdG8gYmUgc3RhdGljIGlmIHRoZXkncmUganVzdCBiZWluZ1xuICAgICAgICAgICAgLy8gdXNlZCB0byBnZXQgdGhlIGNsYXNzbmFtZSBvZiBhIG5lc3RlZCBzdHlsZWQgY29tcG9uZW50XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBTRUVEID0gaGFzaChTQ19WRVJTSU9OKTtcbi8qKlxuICogQ29tcG9uZW50U3R5bGUgaXMgYWxsIHRoZSBDU1Mtc3BlY2lmaWMgc3R1ZmYsIG5vdCB0aGUgUmVhY3Qtc3BlY2lmaWMgc3R1ZmYuXG4gKi9cbnZhciBDb21wb25lbnRTdHlsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21wb25lbnRTdHlsZShydWxlcywgY29tcG9uZW50SWQsIGJhc2VTdHlsZSkge1xuICAgICAgICB0aGlzLm5hbWVzID0gW107XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAgICAgdGhpcy5zdGF0aWNSdWxlc0lkID0gJyc7XG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPVxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIChiYXNlU3R5bGUgPT09IHVuZGVmaW5lZCB8fCBiYXNlU3R5bGUuaXNTdGF0aWMpICYmXG4gICAgICAgICAgICAgICAgaXNTdGF0aWNSdWxlcyhydWxlcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50SWQgPSBjb21wb25lbnRJZDtcbiAgICAgICAgLy8gU0NfVkVSU0lPTiBnaXZlcyB1cyBpc29sYXRpb24gYmV0d2VlbiBtdWx0aXBsZSBydW50aW1lcyBvbiB0aGUgcGFnZSBhdCBvbmNlXG4gICAgICAgIC8vIHRoaXMgaXMgaW1wcm92ZWQgZnVydGhlciB3aXRoIHVzZSBvZiB0aGUgYmFiZWwgcGx1Z2luIFwibmFtZXNwYWNlXCIgZmVhdHVyZVxuICAgICAgICB0aGlzLmJhc2VIYXNoID0gcGhhc2goU0VFRCwgY29tcG9uZW50SWQpO1xuICAgICAgICB0aGlzLmJhc2VTdHlsZSA9IGJhc2VTdHlsZTtcbiAgICAgICAgLy8gTk9URTogVGhpcyByZWdpc3RlcnMgdGhlIGNvbXBvbmVudElkLCB3aGljaCBlbnN1cmVzIGEgY29uc2lzdGVudCBvcmRlclxuICAgICAgICAvLyBmb3IgdGhpcyBjb21wb25lbnQncyBzdHlsZXMgY29tcGFyZWQgdG8gb3RoZXJzXG4gICAgICAgIFN0eWxlU2hlZXQucmVnaXN0ZXJJZChjb21wb25lbnRJZCk7XG4gICAgfVxuICAgIC8qXG4gICAgICogRmxhdHRlbnMgYSBydWxlIHNldCBpbnRvIHZhbGlkIENTU1xuICAgICAqIEhhc2hlcyBpdCwgd3JhcHMgdGhlIHdob2xlIGNodW5rIGluIGEgLmhhc2gxMjM0IHt9XG4gICAgICogUmV0dXJucyB0aGUgaGFzaCB0byBiZSBpbmplY3RlZCBvbiByZW5kZXIoKVxuICAgICAqICovXG4gICAgQ29tcG9uZW50U3R5bGUucHJvdG90eXBlLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzID0gZnVuY3Rpb24gKGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQsIHN0eWxpcykge1xuICAgICAgICB2YXIgY29tcG9uZW50SWQgPSB0aGlzLmNvbXBvbmVudElkO1xuICAgICAgICB0aGlzLm5hbWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmJhc2VTdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lcy5wdXNoKHRoaXMuYmFzZVN0eWxlLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQsIHN0eWxpcykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvcmNlIGR5bmFtaWMgY2xhc3NuYW1lcyBpZiB1c2VyLXN1cHBsaWVkIHN0eWxpcyBwbHVnaW5zIGFyZSBpbiB1c2VcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWMgJiYgIXN0eWxpcy5oYXNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0aWNSdWxlc0lkICYmIHN0eWxlU2hlZXQuaGFzTmFtZUZvcklkKGNvbXBvbmVudElkLCB0aGlzLnN0YXRpY1J1bGVzSWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lcy5wdXNoKHRoaXMuc3RhdGljUnVsZXNJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY3NzU3RhdGljID0gZmxhdHRlbih0aGlzLnJ1bGVzLCBleGVjdXRpb25Db250ZXh0LCBzdHlsZVNoZWV0LCBzdHlsaXMpLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBnZW5lcmF0ZUFscGhhYmV0aWNOYW1lKHBoYXNoKHRoaXMuYmFzZUhhc2gsIGNzc1N0YXRpYykgPj4+IDApO1xuICAgICAgICAgICAgICAgIGlmICghc3R5bGVTaGVldC5oYXNOYW1lRm9ySWQoY29tcG9uZW50SWQsIG5hbWVfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzc1N0YXRpY0Zvcm1hdHRlZCA9IHN0eWxpcyhjc3NTdGF0aWMsIFwiLlwiLmNvbmNhdChuYW1lXzEpLCB1bmRlZmluZWQsIGNvbXBvbmVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlcyhjb21wb25lbnRJZCwgbmFtZV8xLCBjc3NTdGF0aWNGb3JtYXR0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVzLnB1c2gobmFtZV8xKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRpY1J1bGVzSWQgPSBuYW1lXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSB0aGlzLnJ1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBkeW5hbWljSGFzaCA9IHBoYXNoKHRoaXMuYmFzZUhhc2gsIHN0eWxpcy5oYXNoKTtcbiAgICAgICAgICAgIHZhciBjc3MgPSAnJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzE7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0UnVsZSA9IHRoaXMucnVsZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0UnVsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY3NzICs9IHBhcnRSdWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNIYXNoID0gcGhhc2goZHluYW1pY0hhc2gsIHBhcnRSdWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFydFJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRDaHVuayA9IGZsYXR0ZW4ocGFydFJ1bGUsIGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQsIHN0eWxpcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0U3RyaW5nID0gQXJyYXkuaXNBcnJheShwYXJ0Q2h1bmspID8gcGFydENodW5rLmpvaW4oJycpIDogcGFydENodW5rO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljSGFzaCA9IHBoYXNoKGR5bmFtaWNIYXNoLCBwYXJ0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgY3NzICs9IHBhcnRTdHJpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lXzIgPSBnZW5lcmF0ZUFscGhhYmV0aWNOYW1lKGR5bmFtaWNIYXNoID4+PiAwKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlU2hlZXQuaGFzTmFtZUZvcklkKGNvbXBvbmVudElkLCBuYW1lXzIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjc3NGb3JtYXR0ZWQgPSBzdHlsaXMoY3NzLCBcIi5cIi5jb25jYXQobmFtZV8yKSwgdW5kZWZpbmVkLCBjb21wb25lbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZXMoY29tcG9uZW50SWQsIG5hbWVfMiwgY3NzRm9ybWF0dGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lcy5wdXNoKG5hbWVfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZXMuam9pbignICcpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBvbmVudFN0eWxlO1xufSgpKTtcblxudmFyIFRoZW1lQ29udGV4dCA9IFJlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xudmFyIFRoZW1lQ29uc3VtZXIgPSBUaGVtZUNvbnRleHQuQ29uc3VtZXI7XG5mdW5jdGlvbiBtZXJnZVRoZW1lKHRoZW1lLCBvdXRlclRoZW1lKSB7XG4gICAgaWYgKCF0aGVtZSkge1xuICAgICAgICB0aHJvdyB0aHJvd1N0eWxlZENvbXBvbmVudHNFcnJvcigxNCk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKHRoZW1lKSkge1xuICAgICAgICB2YXIgdGhlbWVGbiA9IHRoZW1lO1xuICAgICAgICB2YXIgbWVyZ2VkVGhlbWUgPSB0aGVtZUZuKG91dGVyVGhlbWUpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgKG1lcmdlZFRoZW1lID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkobWVyZ2VkVGhlbWUpIHx8IHR5cGVvZiBtZXJnZWRUaGVtZSAhPT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICB0aHJvdyB0aHJvd1N0eWxlZENvbXBvbmVudHNFcnJvcig3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VkVGhlbWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoZW1lKSB8fCB0eXBlb2YgdGhlbWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IHRocm93U3R5bGVkQ29tcG9uZW50c0Vycm9yKDgpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0ZXJUaGVtZSA/IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvdXRlclRoZW1lKSwgdGhlbWUpIDogdGhlbWU7XG59XG4vKipcbiAqIFByb3ZpZGUgYSB0aGVtZSB0byBhbiBlbnRpcmUgcmVhY3QgY29tcG9uZW50IHRyZWUgdmlhIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gVGhlbWVQcm92aWRlcihwcm9wcykge1xuICAgIHZhciBvdXRlclRoZW1lID0gUmVhY3QudXNlQ29udGV4dChUaGVtZUNvbnRleHQpO1xuICAgIHZhciB0aGVtZUNvbnRleHQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lcmdlVGhlbWUocHJvcHMudGhlbWUsIG91dGVyVGhlbWUpOyB9LCBbcHJvcHMudGhlbWUsIG91dGVyVGhlbWVdKTtcbiAgICBpZiAoIXByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFRoZW1lQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhlbWVDb250ZXh0IH0sIHByb3BzLmNoaWxkcmVuKTtcbn1cblxudmFyIGlkZW50aWZpZXJzID0ge307XG4vKiBXZSBkZXBlbmQgb24gY29tcG9uZW50cyBoYXZpbmcgdW5pcXVlIElEcyAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVJZChkaXNwbGF5TmFtZSwgcGFyZW50Q29tcG9uZW50SWQpIHtcbiAgICB2YXIgbmFtZSA9IHR5cGVvZiBkaXNwbGF5TmFtZSAhPT0gJ3N0cmluZycgPyAnc2MnIDogZXNjYXBlKGRpc3BsYXlOYW1lKTtcbiAgICAvLyBFbnN1cmUgdGhhdCBubyBkaXNwbGF5TmFtZSBjYW4gbGVhZCB0byBkdXBsaWNhdGUgY29tcG9uZW50SWRzXG4gICAgaWRlbnRpZmllcnNbbmFtZV0gPSAoaWRlbnRpZmllcnNbbmFtZV0gfHwgMCkgKyAxO1xuICAgIHZhciBjb21wb25lbnRJZCA9IFwiXCIuY29uY2F0KG5hbWUsIFwiLVwiKS5jb25jYXQoZ2VuZXJhdGVDb21wb25lbnRJZChcbiAgICAvLyBTQ19WRVJTSU9OIGdpdmVzIHVzIGlzb2xhdGlvbiBiZXR3ZWVuIG11bHRpcGxlIHJ1bnRpbWVzIG9uIHRoZSBwYWdlIGF0IG9uY2VcbiAgICAvLyB0aGlzIGlzIGltcHJvdmVkIGZ1cnRoZXIgd2l0aCB1c2Ugb2YgdGhlIGJhYmVsIHBsdWdpbiBcIm5hbWVzcGFjZVwiIGZlYXR1cmVcbiAgICBTQ19WRVJTSU9OICsgbmFtZSArIGlkZW50aWZpZXJzW25hbWVdKSk7XG4gICAgcmV0dXJuIHBhcmVudENvbXBvbmVudElkID8gXCJcIi5jb25jYXQocGFyZW50Q29tcG9uZW50SWQsIFwiLVwiKS5jb25jYXQoY29tcG9uZW50SWQpIDogY29tcG9uZW50SWQ7XG59XG5mdW5jdGlvbiB1c2VJbmplY3RlZFN0eWxlKGNvbXBvbmVudFN0eWxlLCBpc1N0YXRpYywgcmVzb2x2ZWRBdHRycywgd2FyblRvb01hbnlDbGFzc2VzKSB7XG4gICAgdmFyIHN0eWxlU2hlZXQgPSB1c2VTdHlsZVNoZWV0KCk7XG4gICAgdmFyIHN0eWxpcyA9IHVzZVN0eWxpcygpO1xuICAgIHZhciBjbGFzc05hbWUgPSBjb21wb25lbnRTdHlsZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyhpc1N0YXRpYyA/IEVNUFRZX09CSkVDVCA6IHJlc29sdmVkQXR0cnMsIHN0eWxlU2hlZXQsIHN0eWxpcyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgIFJlYWN0LnVzZURlYnVnVmFsdWUoY2xhc3NOYW1lKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNTdGF0aWMgJiYgd2FyblRvb01hbnlDbGFzc2VzKSB7XG4gICAgICAgIHdhcm5Ub29NYW55Q2xhc3NlcyhjbGFzc05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xufVxuZnVuY3Rpb24gdXNlU3R5bGVkQ29tcG9uZW50SW1wbChmb3J3YXJkZWRDb21wb25lbnQsIHByb3BzLCBmb3J3YXJkZWRSZWYsIGlzU3RhdGljKSB7XG4gICAgdmFyIGNvbXBvbmVudEF0dHJzID0gZm9yd2FyZGVkQ29tcG9uZW50LmF0dHJzLCBjb21wb25lbnRTdHlsZSA9IGZvcndhcmRlZENvbXBvbmVudC5jb21wb25lbnRTdHlsZSwgZGVmYXVsdFByb3BzID0gZm9yd2FyZGVkQ29tcG9uZW50LmRlZmF1bHRQcm9wcywgZm9sZGVkQ29tcG9uZW50SWRzID0gZm9yd2FyZGVkQ29tcG9uZW50LmZvbGRlZENvbXBvbmVudElkcywgc2hvdWxkRm9yd2FyZFByb3AgPSBmb3J3YXJkZWRDb21wb25lbnQuc2hvdWxkRm9yd2FyZFByb3AsIHN0eWxlZENvbXBvbmVudElkID0gZm9yd2FyZGVkQ29tcG9uZW50LnN0eWxlZENvbXBvbmVudElkLCB0YXJnZXQgPSBmb3J3YXJkZWRDb21wb25lbnQudGFyZ2V0O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICBSZWFjdC51c2VEZWJ1Z1ZhbHVlKHN0eWxlZENvbXBvbmVudElkKTtcbiAgICAvLyBOT1RFOiB0aGUgbm9uLWhvb2tzIHZlcnNpb24gb25seSBzdWJzY3JpYmVzIHRvIHRoaXMgd2hlbiAhY29tcG9uZW50U3R5bGUuaXNTdGF0aWMsXG4gICAgLy8gYnV0IHRoYXQnZCBiZSBhZ2FpbnN0IHRoZSBydWxlcy1vZi1ob29rcy4gV2UgY291bGQgYmUgbmF1Z2h0eSBhbmQgZG8gaXQgYW55d2F5IGFzIGl0XG4gICAgLy8gc2hvdWxkIGJlIGFuIGltbXV0YWJsZSB2YWx1ZSwgYnV0IGJlaGF2ZSBmb3Igbm93LlxuICAgIHZhciB0aGVtZSA9IGRldGVybWluZVRoZW1lKHByb3BzLCBSZWFjdC51c2VDb250ZXh0KFRoZW1lQ29udGV4dCksIGRlZmF1bHRQcm9wcykgfHwgRU1QVFlfT0JKRUNUO1xuICAgIHZhciBjb250ZXh0ID0gY29tcG9uZW50QXR0cnMucmVkdWNlKGZ1bmN0aW9uIChwLCBhdHRyRGVmKSB7XG4gICAgICAgIHZhciByZXNvbHZlZEF0dHJEZWYgPSB0eXBlb2YgYXR0ckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IGF0dHJEZWYocCkgOiBhdHRyRGVmO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHJlc29sdmVkQXR0ckRlZikge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBiYWQgdHlwZXNcbiAgICAgICAgICAgIHBba2V5XSA9XG4gICAgICAgICAgICAgICAga2V5ID09PSAnY2xhc3NOYW1lJ1xuICAgICAgICAgICAgICAgICAgICA/IGpvaW5TdHJpbmdzKHBba2V5XSwgcmVzb2x2ZWRBdHRyRGVmW2tleV0pXG4gICAgICAgICAgICAgICAgICAgIDoga2V5ID09PSAnc3R5bGUnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBwW2tleV0pLCByZXNvbHZlZEF0dHJEZWZba2V5XSkgOiByZXNvbHZlZEF0dHJEZWZba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGd1YXJkLWZvci1pbiAqL1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9LCB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgcHJvcHMpLCB7IHRoZW1lOiB0aGVtZSB9KSk7XG4gICAgdmFyIGdlbmVyYXRlZENsYXNzTmFtZSA9IHVzZUluamVjdGVkU3R5bGUoY29tcG9uZW50U3R5bGUsIGlzU3RhdGljLCBjb250ZXh0LCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gZm9yd2FyZGVkQ29tcG9uZW50Lndhcm5Ub29NYW55Q2xhc3NlcyA6IHVuZGVmaW5lZCk7XG4gICAgdmFyIHJlZlRvRm9yd2FyZCA9IGZvcndhcmRlZFJlZjtcbiAgICB2YXIgZWxlbWVudFRvQmVDcmVhdGVkID0gY29udGV4dC5hcyB8fCB0YXJnZXQ7XG4gICAgdmFyIGlzVGFyZ2V0VGFnID0gaXNUYWcoZWxlbWVudFRvQmVDcmVhdGVkKTtcbiAgICB2YXIgcHJvcHNGb3JFbGVtZW50ID0ge307XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAodmFyIGtleSBpbiBjb250ZXh0KSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZm9yLi5pbiBpdGVyYXRlcyBzdHJpbmdzIGluc3RlYWQgb2Yga2V5b2ZcbiAgICAgICAgaWYgKGNvbnRleHRba2V5XSA9PT0gdW5kZWZpbmVkKSA7XG4gICAgICAgIGVsc2UgaWYgKGtleVswXSA9PT0gJyQnIHx8IGtleSA9PT0gJ2FzJyB8fCBrZXkgPT09ICd0aGVtZScpIDtcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZm9yd2FyZGVkQXMnKSB7XG4gICAgICAgICAgICBwcm9wc0ZvckVsZW1lbnQuYXMgPSBjb250ZXh0LmZvcndhcmRlZEFzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzaG91bGRGb3J3YXJkUHJvcCB8fCBzaG91bGRGb3J3YXJkUHJvcChrZXksIGVsZW1lbnRUb0JlQ3JlYXRlZCkpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZm9yLi5pbiBpdGVyYXRlcyBzdHJpbmdzIGluc3RlYWQgb2Yga2V5b2ZcbiAgICAgICAgICAgIHByb3BzRm9yRWxlbWVudFtrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3BzRm9yRWxlbWVudFtcbiAgICAvLyBoYW5kbGUgY3VzdG9tIGVsZW1lbnRzIHdoaWNoIFJlYWN0IGRvZXNuJ3QgcHJvcGVybHkgYWxpYXNcbiAgICBpc1RhcmdldFRhZyAmJlxuICAgICAgICBkb21FbGVtZW50cy5pbmRleE9mKGVsZW1lbnRUb0JlQ3JlYXRlZCkgPT09IC0xXG4gICAgICAgID8gJ2NsYXNzJ1xuICAgICAgICA6ICdjbGFzc05hbWUnXSA9IGZvbGRlZENvbXBvbmVudElkc1xuICAgICAgICAuY29uY2F0KHN0eWxlZENvbXBvbmVudElkLCBnZW5lcmF0ZWRDbGFzc05hbWUgIT09IHN0eWxlZENvbXBvbmVudElkID8gZ2VuZXJhdGVkQ2xhc3NOYW1lIDogJycsIGNvbnRleHQuY2xhc3NOYW1lIHx8ICcnKVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIC5qb2luKCcgJyk7XG4gICAgcHJvcHNGb3JFbGVtZW50LnJlZiA9IHJlZlRvRm9yd2FyZDtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChlbGVtZW50VG9CZUNyZWF0ZWQsIHByb3BzRm9yRWxlbWVudCk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdHlsZWRDb21wb25lbnQodGFyZ2V0LCBvcHRpb25zLCBydWxlcykge1xuICAgIHZhciBpc1RhcmdldFN0eWxlZENvbXAgPSBpc1N0eWxlZENvbXBvbmVudCh0YXJnZXQpO1xuICAgIHZhciBzdHlsZWRDb21wb25lbnRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgdmFyIGlzQ29tcG9zaXRlQ29tcG9uZW50ID0gIWlzVGFnKHRhcmdldCk7XG4gICAgdmFyIF9hID0gb3B0aW9ucy5hdHRycywgYXR0cnMgPSBfYSA9PT0gdm9pZCAwID8gRU1QVFlfQVJSQVkgOiBfYSwgX2IgPSBvcHRpb25zLmNvbXBvbmVudElkLCBjb21wb25lbnRJZCA9IF9iID09PSB2b2lkIDAgPyBnZW5lcmF0ZUlkKG9wdGlvbnMuZGlzcGxheU5hbWUsIG9wdGlvbnMucGFyZW50Q29tcG9uZW50SWQpIDogX2IsIF9jID0gb3B0aW9ucy5kaXNwbGF5TmFtZSwgZGlzcGxheU5hbWUgPSBfYyA9PT0gdm9pZCAwID8gZ2VuZXJhdGVEaXNwbGF5TmFtZSh0YXJnZXQpIDogX2M7XG4gICAgdmFyIHN0eWxlZENvbXBvbmVudElkID0gb3B0aW9ucy5kaXNwbGF5TmFtZSAmJiBvcHRpb25zLmNvbXBvbmVudElkXG4gICAgICAgID8gXCJcIi5jb25jYXQoZXNjYXBlKG9wdGlvbnMuZGlzcGxheU5hbWUpLCBcIi1cIikuY29uY2F0KG9wdGlvbnMuY29tcG9uZW50SWQpXG4gICAgICAgIDogb3B0aW9ucy5jb21wb25lbnRJZCB8fCBjb21wb25lbnRJZDtcbiAgICAvLyBmb2xkIHRoZSB1bmRlcmx5aW5nIFN0eWxlZENvbXBvbmVudCBhdHRycyB1cCAoaW1wbGljaXQgZXh0ZW5kKVxuICAgIHZhciBmaW5hbEF0dHJzID0gaXNUYXJnZXRTdHlsZWRDb21wICYmIHN0eWxlZENvbXBvbmVudFRhcmdldC5hdHRyc1xuICAgICAgICA/IHN0eWxlZENvbXBvbmVudFRhcmdldC5hdHRyc1xuICAgICAgICAgICAgLmNvbmNhdChhdHRycylcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgOiBhdHRycztcbiAgICB2YXIgc2hvdWxkRm9yd2FyZFByb3AgPSBvcHRpb25zLnNob3VsZEZvcndhcmRQcm9wO1xuICAgIGlmIChpc1RhcmdldFN0eWxlZENvbXAgJiYgc3R5bGVkQ29tcG9uZW50VGFyZ2V0LnNob3VsZEZvcndhcmRQcm9wKSB7XG4gICAgICAgIHZhciBzaG91bGRGb3J3YXJkUHJvcEZuXzEgPSBzdHlsZWRDb21wb25lbnRUYXJnZXQuc2hvdWxkRm9yd2FyZFByb3A7XG4gICAgICAgIGlmIChvcHRpb25zLnNob3VsZEZvcndhcmRQcm9wKSB7XG4gICAgICAgICAgICB2YXIgcGFzc2VkU2hvdWxkRm9yd2FyZFByb3BGbl8xID0gb3B0aW9ucy5zaG91bGRGb3J3YXJkUHJvcDtcbiAgICAgICAgICAgIC8vIGNvbXBvc2UgbmVzdGVkIHNob3VsZEZvcndhcmRQcm9wIGNhbGxzXG4gICAgICAgICAgICBzaG91bGRGb3J3YXJkUHJvcCA9IGZ1bmN0aW9uIChwcm9wLCBlbGVtZW50VG9CZUNyZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkRm9yd2FyZFByb3BGbl8xKHByb3AsIGVsZW1lbnRUb0JlQ3JlYXRlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFzc2VkU2hvdWxkRm9yd2FyZFByb3BGbl8xKHByb3AsIGVsZW1lbnRUb0JlQ3JlYXRlZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2hvdWxkRm9yd2FyZFByb3AgPSBzaG91bGRGb3J3YXJkUHJvcEZuXzE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNvbXBvbmVudFN0eWxlID0gbmV3IENvbXBvbmVudFN0eWxlKHJ1bGVzLCBzdHlsZWRDb21wb25lbnRJZCwgaXNUYXJnZXRTdHlsZWRDb21wID8gc3R5bGVkQ29tcG9uZW50VGFyZ2V0LmNvbXBvbmVudFN0eWxlIDogdW5kZWZpbmVkKTtcbiAgICAvLyBzdGF0aWNhbGx5IHN0eWxlZC1jb21wb25lbnRzIGRvbid0IG5lZWQgdG8gYnVpbGQgYW4gZXhlY3V0aW9uIGNvbnRleHQgb2JqZWN0LFxuICAgIC8vIGFuZCBzaG91bGRuJ3QgYmUgaW5jcmVhc2luZyB0aGUgbnVtYmVyIG9mIGNsYXNzIG5hbWVzXG4gICAgdmFyIGlzU3RhdGljID0gY29tcG9uZW50U3R5bGUuaXNTdGF0aWMgJiYgYXR0cnMubGVuZ3RoID09PSAwO1xuICAgIGZ1bmN0aW9uIGZvcndhcmRSZWYocHJvcHMsIHJlZikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgcmV0dXJuIHVzZVN0eWxlZENvbXBvbmVudEltcGwoV3JhcHBlZFN0eWxlZENvbXBvbmVudCwgcHJvcHMsIHJlZiwgaXNTdGF0aWMpO1xuICAgIH1cbiAgICBmb3J3YXJkUmVmLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgLyoqXG4gICAgICogZm9yd2FyZFJlZiBjcmVhdGVzIGEgbmV3IGludGVyaW0gY29tcG9uZW50LCB3aGljaCB3ZSdsbCB0YWtlIGFkdmFudGFnZSBvZlxuICAgICAqIGluc3RlYWQgb2YgZXh0ZW5kaW5nIFBhcmVudENvbXBvbmVudCB0byBjcmVhdGUgX2Fub3RoZXJfIGludGVyaW0gY2xhc3NcbiAgICAgKi9cbiAgICB2YXIgV3JhcHBlZFN0eWxlZENvbXBvbmVudCA9IFJlYWN0X19kZWZhdWx0LmRlZmF1bHQuZm9yd2FyZFJlZihmb3J3YXJkUmVmKTtcbiAgICBXcmFwcGVkU3R5bGVkQ29tcG9uZW50LmF0dHJzID0gZmluYWxBdHRycztcbiAgICBXcmFwcGVkU3R5bGVkQ29tcG9uZW50LmNvbXBvbmVudFN0eWxlID0gY29tcG9uZW50U3R5bGU7XG4gICAgV3JhcHBlZFN0eWxlZENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIFdyYXBwZWRTdHlsZWRDb21wb25lbnQuc2hvdWxkRm9yd2FyZFByb3AgPSBzaG91bGRGb3J3YXJkUHJvcDtcbiAgICAvLyB0aGlzIHN0YXRpYyBpcyB1c2VkIHRvIHByZXNlcnZlIHRoZSBjYXNjYWRlIG9mIHN0YXRpYyBjbGFzc2VzIGZvciBjb21wb25lbnQgc2VsZWN0b3JcbiAgICAvLyBwdXJwb3NlczsgdGhpcyBpcyBlc3BlY2lhbGx5IGltcG9ydGFudCB3aXRoIHVzYWdlIG9mIHRoZSBjc3MgcHJvcFxuICAgIFdyYXBwZWRTdHlsZWRDb21wb25lbnQuZm9sZGVkQ29tcG9uZW50SWRzID0gaXNUYXJnZXRTdHlsZWRDb21wXG4gICAgICAgID8gc3R5bGVkQ29tcG9uZW50VGFyZ2V0LmZvbGRlZENvbXBvbmVudElkcy5jb25jYXQoc3R5bGVkQ29tcG9uZW50VGFyZ2V0LnN0eWxlZENvbXBvbmVudElkKVxuICAgICAgICA6IEVNUFRZX0FSUkFZO1xuICAgIFdyYXBwZWRTdHlsZWRDb21wb25lbnQuc3R5bGVkQ29tcG9uZW50SWQgPSBzdHlsZWRDb21wb25lbnRJZDtcbiAgICAvLyBmb2xkIHRoZSB1bmRlcmx5aW5nIFN0eWxlZENvbXBvbmVudCB0YXJnZXQgdXAgc2luY2Ugd2UgZm9sZGVkIHRoZSBzdHlsZXNcbiAgICBXcmFwcGVkU3R5bGVkQ29tcG9uZW50LnRhcmdldCA9IGlzVGFyZ2V0U3R5bGVkQ29tcCA/IHN0eWxlZENvbXBvbmVudFRhcmdldC50YXJnZXQgOiB0YXJnZXQ7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRTdHlsZWRDb21wb25lbnQsICdkZWZhdWx0UHJvcHMnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbGRlZERlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2xkZWREZWZhdWx0UHJvcHMgPSBpc1RhcmdldFN0eWxlZENvbXBcbiAgICAgICAgICAgICAgICA/IG1peGluRGVlcCh7fSwgc3R5bGVkQ29tcG9uZW50VGFyZ2V0LmRlZmF1bHRQcm9wcywgb2JqKVxuICAgICAgICAgICAgICAgIDogb2JqO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrRHluYW1pY0NyZWF0aW9uKGRpc3BsYXlOYW1lLCBzdHlsZWRDb21wb25lbnRJZCk7XG4gICAgICAgIFdyYXBwZWRTdHlsZWRDb21wb25lbnQud2FyblRvb01hbnlDbGFzc2VzID0gY3JlYXRlV2FyblRvb01hbnlDbGFzc2VzKGRpc3BsYXlOYW1lLCBzdHlsZWRDb21wb25lbnRJZCk7XG4gICAgfVxuICAgIFdyYXBwZWRTdHlsZWRDb21wb25lbnQudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIi5cIi5jb25jYXQoV3JhcHBlZFN0eWxlZENvbXBvbmVudC5zdHlsZWRDb21wb25lbnRJZCk7IH07XG4gICAgaWYgKGlzQ29tcG9zaXRlQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBjb21wb3NpdGVDb21wb25lbnRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKFdyYXBwZWRTdHlsZWRDb21wb25lbnQsIGNvbXBvc2l0ZUNvbXBvbmVudFRhcmdldCwge1xuICAgICAgICAgICAgLy8gYWxsIFNDLXNwZWNpZmljIHRoaW5ncyBzaG91bGQgbm90IGJlIGhvaXN0ZWRcbiAgICAgICAgICAgIGF0dHJzOiB0cnVlLFxuICAgICAgICAgICAgY29tcG9uZW50U3R5bGU6IHRydWUsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGRlZENvbXBvbmVudElkczogdHJ1ZSxcbiAgICAgICAgICAgIHNob3VsZEZvcndhcmRQcm9wOiB0cnVlLFxuICAgICAgICAgICAgc3R5bGVkQ29tcG9uZW50SWQ6IHRydWUsXG4gICAgICAgICAgICB0YXJnZXQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gV3JhcHBlZFN0eWxlZENvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gaW50ZXJsZWF2ZShzdHJpbmdzLCBpbnRlcnBvbGF0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSBbc3RyaW5nc1swXV07XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGludGVycG9sYXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGludGVycG9sYXRpb25zW2ldLCBzdHJpbmdzW2kgKyAxXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVXNlZCB3aGVuIGZsYXR0ZW5pbmcgb2JqZWN0IHN0eWxlcyB0byBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkXG4gKiBleHBhbmQgYW4gYXJyYXkgb2Ygc3R5bGVzLlxuICovXG52YXIgYWRkVGFnID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFyZywgeyBpc0NzczogdHJ1ZSB9KTtcbn07XG5mdW5jdGlvbiBjc3Moc3R5bGVzKSB7XG4gICAgdmFyIGludGVycG9sYXRpb25zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgaW50ZXJwb2xhdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKHN0eWxlcykgfHwgaXNQbGFpbk9iamVjdChzdHlsZXMpKSB7XG4gICAgICAgIHZhciBzdHlsZUZ1bmN0aW9uT3JPYmplY3QgPSBzdHlsZXM7XG4gICAgICAgIHJldHVybiBhZGRUYWcoZmxhdHRlbihpbnRlcmxlYXZlKEVNUFRZX0FSUkFZLCB0c2xpYi5fX3NwcmVhZEFycmF5KFtcbiAgICAgICAgICAgIHN0eWxlRnVuY3Rpb25Pck9iamVjdFxuICAgICAgICBdLCBpbnRlcnBvbGF0aW9ucywgdHJ1ZSkpKSk7XG4gICAgfVxuICAgIHZhciBzdHlsZVN0cmluZ0FycmF5ID0gc3R5bGVzO1xuICAgIGlmIChpbnRlcnBvbGF0aW9ucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgc3R5bGVTdHJpbmdBcnJheS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgdHlwZW9mIHN0eWxlU3RyaW5nQXJyYXlbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmbGF0dGVuKHN0eWxlU3RyaW5nQXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkVGFnKGZsYXR0ZW4oaW50ZXJsZWF2ZShzdHlsZVN0cmluZ0FycmF5LCBpbnRlcnBvbGF0aW9ucykpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0V2l0aE9wdGlvbnMoY29tcG9uZW50Q29uc3RydWN0b3IsIHRhZywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IEVNUFRZX09CSkVDVDsgfVxuICAgIC8vIFdlIHRydXN0IHRoYXQgdGhlIHRhZyBpcyBhIHZhbGlkIGNvbXBvbmVudCBhcyBsb25nIGFzIGl0IGlzbid0IGZhbHNpc2hcbiAgICAvLyBUeXBpY2FsbHkgdGhlIHRhZyBoZXJlIGlzIGEgc3RyaW5nIG9yIGZ1bmN0aW9uIChpLmUuIGNsYXNzIG9yIHB1cmUgZnVuY3Rpb24gY29tcG9uZW50KVxuICAgIC8vIEhvd2V2ZXIgYSBjb21wb25lbnQgbWF5IGFsc28gYmUgYW4gb2JqZWN0IGlmIGl0IHVzZXMgYW5vdGhlciB1dGlsaXR5LCBlLmcuIFJlYWN0Lm1lbW9cbiAgICAvLyBSZWFjdCB3aWxsIG91dHB1dCBhbiBhcHByb3ByaWF0ZSB3YXJuaW5nIGhvd2V2ZXIgaWYgdGhlIGB0YWdgIGlzbid0IHZhbGlkXG4gICAgaWYgKCF0YWcpIHtcbiAgICAgICAgdGhyb3cgdGhyb3dTdHlsZWRDb21wb25lbnRzRXJyb3IoMSwgdGFnKTtcbiAgICB9XG4gICAgLyogVGhpcyBpcyBjYWxsYWJsZSBkaXJlY3RseSBhcyBhIHRlbXBsYXRlIGZ1bmN0aW9uICovXG4gICAgdmFyIHRlbXBsYXRlRnVuY3Rpb24gPSBmdW5jdGlvbiAoaW5pdGlhbFN0eWxlcykge1xuICAgICAgICB2YXIgaW50ZXJwb2xhdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGludGVycG9sYXRpb25zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRDb25zdHJ1Y3Rvcih0YWcsIG9wdGlvbnMsIGNzcy5hcHBseSh2b2lkIDAsIHRzbGliLl9fc3ByZWFkQXJyYXkoW2luaXRpYWxTdHlsZXNdLCBpbnRlcnBvbGF0aW9ucywgZmFsc2UpKSk7XG4gICAgfTtcbiAgICAvKiBNb2RpZnkvaW5qZWN0IG5ldyBwcm9wcyBhdCBydW50aW1lICovXG4gICAgdGVtcGxhdGVGdW5jdGlvbi5hdHRycyA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0V2l0aE9wdGlvbnMoY29tcG9uZW50Q29uc3RydWN0b3IsIHRhZywgdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGF0dHJzOiBBcnJheS5wcm90b3R5cGUuY29uY2F0KG9wdGlvbnMuYXR0cnMsIGF0dHJzKS5maWx0ZXIoQm9vbGVhbikgfSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgY29uZmlnIG1ldGhvZHMgYXJlIGNhbGxlZCwgd3JhcCB1cCBhIG5ldyB0ZW1wbGF0ZSBmdW5jdGlvbiBhbmQgbWVyZ2Ugb3B0aW9ucyAqL1xuICAgIHRlbXBsYXRlRnVuY3Rpb24ud2l0aENvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFdpdGhPcHRpb25zKGNvbXBvbmVudENvbnN0cnVjdG9yLCB0YWcsIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgY29uZmlnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gdGVtcGxhdGVGdW5jdGlvbjtcbn1cblxudmFyIGJhc2VTdHlsZWQgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdFdpdGhPcHRpb25zKGNyZWF0ZVN0eWxlZENvbXBvbmVudCwgdGFnKTtcbn07XG52YXIgc3R5bGVkID0gYmFzZVN0eWxlZDtcbi8vIFNob3J0aGFuZHMgZm9yIGFsbCB2YWxpZCBIVE1MIEVsZW1lbnRzXG5kb21FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkb21FbGVtZW50KSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzb21lZGF5IHRoZXknbGwgaGFuZGxlIGltcGVyYXRpdmUgYXNzaWdubWVudCBwcm9wZXJseVxuICAgIHN0eWxlZFtkb21FbGVtZW50XSA9IGJhc2VTdHlsZWQoZG9tRWxlbWVudCk7XG59KTtcblxudmFyIEdsb2JhbFN0eWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdsb2JhbFN0eWxlKHJ1bGVzLCBjb21wb25lbnRJZCkge1xuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgICAgIHRoaXMuY29tcG9uZW50SWQgPSBjb21wb25lbnRJZDtcbiAgICAgICAgdGhpcy5pc1N0YXRpYyA9IGlzU3RhdGljUnVsZXMocnVsZXMpO1xuICAgICAgICAvLyBwcmUtcmVnaXN0ZXIgdGhlIGZpcnN0IGluc3RhbmNlIHRvIGVuc3VyZSBnbG9iYWwgc3R5bGVzXG4gICAgICAgIC8vIGxvYWQgYmVmb3JlIGNvbXBvbmVudCBvbmVzXG4gICAgICAgIFN0eWxlU2hlZXQucmVnaXN0ZXJJZCh0aGlzLmNvbXBvbmVudElkICsgMSk7XG4gICAgfVxuICAgIEdsb2JhbFN0eWxlLnByb3RvdHlwZS5jcmVhdGVTdHlsZXMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQsIHN0eWxpcykge1xuICAgICAgICB2YXIgZmxhdENTUyA9IGZsYXR0ZW4odGhpcy5ydWxlcywgZXhlY3V0aW9uQ29udGV4dCwgc3R5bGVTaGVldCwgc3R5bGlzKTtcbiAgICAgICAgdmFyIGNzcyA9IHN0eWxpcyhmbGF0Q1NTLmpvaW4oJycpLCAnJyk7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuY29tcG9uZW50SWQgKyBpbnN0YW5jZTtcbiAgICAgICAgLy8gTk9URTogV2UgdXNlIHRoZSBpZCBhcyBhIG5hbWUgYXMgd2VsbCwgc2luY2UgdGhlc2UgcnVsZXMgbmV2ZXIgY2hhbmdlXG4gICAgICAgIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZXMoaWQsIGlkLCBjc3MpO1xuICAgIH07XG4gICAgR2xvYmFsU3R5bGUucHJvdG90eXBlLnJlbW92ZVN0eWxlcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZVNoZWV0LmNsZWFyUnVsZXModGhpcy5jb21wb25lbnRJZCArIGluc3RhbmNlKTtcbiAgICB9O1xuICAgIEdsb2JhbFN0eWxlLnByb3RvdHlwZS5yZW5kZXJTdHlsZXMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQsIHN0eWxpcykge1xuICAgICAgICBpZiAoaW5zdGFuY2UgPiAyKVxuICAgICAgICAgICAgU3R5bGVTaGVldC5yZWdpc3RlcklkKHRoaXMuY29tcG9uZW50SWQgKyBpbnN0YW5jZSk7XG4gICAgICAgIC8vIE5PVEU6IFJlbW92ZSBvbGQgc3R5bGVzLCB0aGVuIGluamVjdCB0aGUgbmV3IG9uZXNcbiAgICAgICAgdGhpcy5yZW1vdmVTdHlsZXMoaW5zdGFuY2UsIHN0eWxlU2hlZXQpO1xuICAgICAgICB0aGlzLmNyZWF0ZVN0eWxlcyhpbnN0YW5jZSwgZXhlY3V0aW9uQ29udGV4dCwgc3R5bGVTaGVldCwgc3R5bGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBHbG9iYWxTdHlsZTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUdsb2JhbFN0eWxlKHN0cmluZ3MpIHtcbiAgICB2YXIgaW50ZXJwb2xhdGlvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBpbnRlcnBvbGF0aW9uc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHJ1bGVzID0gY3NzLmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheShbc3RyaW5nc10sIGludGVycG9sYXRpb25zLCBmYWxzZSkpO1xuICAgIHZhciBzdHlsZWRDb21wb25lbnRJZCA9IFwic2MtZ2xvYmFsLVwiLmNvbmNhdChnZW5lcmF0ZUNvbXBvbmVudElkKEpTT04uc3RyaW5naWZ5KHJ1bGVzKSkpO1xuICAgIHZhciBnbG9iYWxTdHlsZSA9IG5ldyBHbG9iYWxTdHlsZShydWxlcywgc3R5bGVkQ29tcG9uZW50SWQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrRHluYW1pY0NyZWF0aW9uKHN0eWxlZENvbXBvbmVudElkKTtcbiAgICB9XG4gICAgdmFyIEdsb2JhbFN0eWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBzdHlsZVNoZWV0ID0gdXNlU3R5bGVTaGVldCgpO1xuICAgICAgICB2YXIgc3R5bGlzID0gdXNlU3R5bGlzKCk7XG4gICAgICAgIHZhciB0aGVtZSA9IFJlYWN0X19kZWZhdWx0LmRlZmF1bHQudXNlQ29udGV4dChUaGVtZUNvbnRleHQpO1xuICAgICAgICB2YXIgaW5zdGFuY2VSZWYgPSBSZWFjdF9fZGVmYXVsdC5kZWZhdWx0LnVzZVJlZihzdHlsZVNoZWV0LmFsbG9jYXRlR1NJbnN0YW5jZShzdHlsZWRDb21wb25lbnRJZCkpO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBSZWFjdF9fZGVmYXVsdC5kZWZhdWx0LkNoaWxkcmVuLmNvdW50KHByb3BzLmNoaWxkcmVuKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBnbG9iYWwgc3R5bGUgY29tcG9uZW50IFwiLmNvbmNhdChzdHlsZWRDb21wb25lbnRJZCwgXCIgd2FzIGdpdmVuIGNoaWxkIEpTWC4gY3JlYXRlR2xvYmFsU3R5bGUgZG9lcyBub3QgcmVuZGVyIGNoaWxkcmVuLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgIHJ1bGVzLnNvbWUoZnVuY3Rpb24gKHJ1bGUpIHsgcmV0dXJuIHR5cGVvZiBydWxlID09PSAnc3RyaW5nJyAmJiBydWxlLmluZGV4T2YoJ0BpbXBvcnQnKSAhPT0gLTE7IH0pKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUGxlYXNlIGRvIG5vdCB1c2UgQGltcG9ydCBDU1Mgc3ludGF4IGluIGNyZWF0ZUdsb2JhbFN0eWxlIGF0IHRoaXMgdGltZSwgYXMgdGhlIENTU09NIEFQSXMgd2UgdXNlIGluIHByb2R1Y3Rpb24gZG8gbm90IGhhbmRsZSBpdCB3ZWxsLiBJbnN0ZWFkLCB3ZSByZWNvbW1lbmQgdXNpbmcgYSBsaWJyYXJ5IHN1Y2ggYXMgcmVhY3QtaGVsbWV0IHRvIGluamVjdCBhIHR5cGljYWwgPGxpbms+IG1ldGEgdGFnIHRvIHRoZSBzdHlsZXNoZWV0LCBvciBzaW1wbHkgZW1iZWRkaW5nIGl0IG1hbnVhbGx5IGluIHlvdXIgaW5kZXguaHRtbCA8aGVhZD4gc2VjdGlvbiBmb3IgYSBzaW1wbGVyIGFwcC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlU2hlZXQuc2VydmVyKSB7XG4gICAgICAgICAgICByZW5kZXJTdHlsZXMoaW5zdGFuY2UsIHByb3BzLCBzdHlsZVNoZWV0LCB0aGVtZSwgc3R5bGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlbmRlclN0eWxlcyhpbnN0YW5jZSwgcHJvcHMsIHN0eWxlU2hlZXQsIHRoZW1lLCBzdHlsaXMpIHtcbiAgICAgICAgaWYgKGdsb2JhbFN0eWxlLmlzU3RhdGljKSB7XG4gICAgICAgICAgICBnbG9iYWxTdHlsZS5yZW5kZXJTdHlsZXMoaW5zdGFuY2UsIFNUQVRJQ19FWEVDVVRJT05fQ09OVEVYVCwgc3R5bGVTaGVldCwgc3R5bGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHByb3BzKSwgeyB0aGVtZTogZGV0ZXJtaW5lVGhlbWUocHJvcHMsIHRoZW1lLCBHbG9iYWxTdHlsZUNvbXBvbmVudC5kZWZhdWx0UHJvcHMpIH0pO1xuICAgICAgICAgICAgZ2xvYmFsU3R5bGUucmVuZGVyU3R5bGVzKGluc3RhbmNlLCBjb250ZXh0LCBzdHlsZVNoZWV0LCBzdHlsaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5kZWZhdWx0Lm1lbW8oR2xvYmFsU3R5bGVDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBrZXlmcmFtZXMoc3RyaW5ncykge1xuICAgIHZhciBpbnRlcnBvbGF0aW9ucyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGludGVycG9sYXRpb25zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICAvKiBXYXJuaW5nIGlmIHlvdSd2ZSB1c2VkIGtleWZyYW1lcyBvbiBSZWFjdCBOYXRpdmUgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oJ2BrZXlmcmFtZXNgIGNhbm5vdCBiZSB1c2VkIG9uIFJlYWN0TmF0aXZlLCBvbmx5IG9uIHRoZSB3ZWIuIFRvIGRvIGFuaW1hdGlvbiBpbiBSZWFjdE5hdGl2ZSBwbGVhc2UgdXNlIEFuaW1hdGVkLicpO1xuICAgIH1cbiAgICB2YXIgcnVsZXMgPSBjc3MuYXBwbHkodm9pZCAwLCB0c2xpYi5fX3NwcmVhZEFycmF5KFtzdHJpbmdzXSwgaW50ZXJwb2xhdGlvbnMsIGZhbHNlKSkuam9pbignJyk7XG4gICAgdmFyIG5hbWUgPSBnZW5lcmF0ZUNvbXBvbmVudElkKHJ1bGVzKTtcbiAgICByZXR1cm4gbmV3IEtleWZyYW1lcyhuYW1lLCBydWxlcyk7XG59XG5cbmZ1bmN0aW9uIHdpdGhUaGVtZShDb21wb25lbnQpIHtcbiAgICB2YXIgV2l0aFRoZW1lID0gUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gICAgICAgIHZhciB0aGVtZSA9IFJlYWN0X19kZWZhdWx0LmRlZmF1bHQudXNlQ29udGV4dChUaGVtZUNvbnRleHQpO1xuICAgICAgICB2YXIgdGhlbWVQcm9wID0gZGV0ZXJtaW5lVGhlbWUocHJvcHMsIHRoZW1lLCBDb21wb25lbnQuZGVmYXVsdFByb3BzKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhlbWVQcm9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbd2l0aFRoZW1lXSBZb3UgYXJlIG5vdCB1c2luZyBhIFRoZW1lUHJvdmlkZXIgbm9yIHBhc3NpbmcgYSB0aGVtZSBwcm9wIG9yIGEgdGhlbWUgaW4gZGVmYXVsdFByb3BzIGluIGNvbXBvbmVudCBjbGFzcyBcXFwiXCIuY29uY2F0KGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSwgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgdHNsaWIuX19hc3NpZ24oe30sIHByb3BzLCB7IHRoZW1lOiB0aGVtZVByb3AsIHJlZjogcmVmIH0pKTtcbiAgICB9KTtcbiAgICBXaXRoVGhlbWUuZGlzcGxheU5hbWUgPSBcIldpdGhUaGVtZShcIi5jb25jYXQoZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpLCBcIilcIik7XG4gICAgcmV0dXJuIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKFdpdGhUaGVtZSwgQ29tcG9uZW50KTtcbn1cblxudmFyIHVzZVRoZW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gUmVhY3QudXNlQ29udGV4dChUaGVtZUNvbnRleHQpOyB9O1xuXG52YXIgQ0xPU0lOR19UQUdfUiA9IC9eXFxzKjxcXC9bYS16XS9pO1xudmFyIFNlcnZlclN0eWxlU2hlZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VydmVyU3R5bGVTaGVldCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZW1pdFNoZWV0Q1NTID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNzcyA9IF90aGlzLmluc3RhbmNlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gW1xuICAgICAgICAgICAgICAgIG5vbmNlICYmIFwibm9uY2U9XFxcIlwiLmNvbmNhdChub25jZSwgXCJcXFwiXCIpLFxuICAgICAgICAgICAgICAgIFwiXCIuY29uY2F0KFNDX0FUVFIsIFwiPVxcXCJ0cnVlXFxcIlwiKSxcbiAgICAgICAgICAgICAgICBcIlwiLmNvbmNhdChTQ19BVFRSX1ZFUlNJT04sIFwiPVxcXCJcIikuY29uY2F0KFNDX1ZFUlNJT04sIFwiXFxcIlwiKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgaHRtbEF0dHIgPSBhdHRycy5maWx0ZXIoQm9vbGVhbikuam9pbignICcpO1xuICAgICAgICAgICAgcmV0dXJuIFwiPHN0eWxlIFwiLmNvbmNhdChodG1sQXR0ciwgXCI+XCIpLmNvbmNhdChjc3MsIFwiPC9zdHlsZT5cIik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0U3R5bGVUYWdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnNlYWxlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IHRocm93U3R5bGVkQ29tcG9uZW50c0Vycm9yKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9lbWl0U2hlZXRDU1MoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRTdHlsZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2VhbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhyb3dTdHlsZWRDb21wb25lbnRzRXJyb3IoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSAoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICBfYVtTQ19BVFRSXSA9ICcnLFxuICAgICAgICAgICAgICAgIF9hW1NDX0FUVFJfVkVSU0lPTl0gPSBTQ19WRVJTSU9OLFxuICAgICAgICAgICAgICAgIF9hLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID0ge1xuICAgICAgICAgICAgICAgICAgICBfX2h0bWw6IF90aGlzLmluc3RhbmNlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfYSk7XG4gICAgICAgICAgICB2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuICAgICAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMubm9uY2UgPSBub25jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHY0IHJldHVybmVkIGFuIGFycmF5IGZvciB0aGlzIGZuLCBzbyB3ZSdsbCBkbyB0aGUgc2FtZSBmb3IgdjUgZm9yIGJhY2t3YXJkIGNvbXBhdFxuICAgICAgICAgICAgcmV0dXJuIFtSZWFjdF9fZGVmYXVsdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB0c2xpYi5fX2Fzc2lnbih7fSwgcHJvcHMsIHsga2V5OiBcInNjLTAtMFwiIH0pKV07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNlYWxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgU3R5bGVTaGVldCh7IGlzU2VydmVyOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnNlYWxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBTZXJ2ZXJTdHlsZVNoZWV0LnByb3RvdHlwZS5jb2xsZWN0U3R5bGVzID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICh0aGlzLnNlYWxlZCkge1xuICAgICAgICAgICAgdGhyb3cgdGhyb3dTdHlsZWRDb21wb25lbnRzRXJyb3IoMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZVNoZWV0TWFuYWdlciwgeyBzaGVldDogdGhpcy5pbnN0YW5jZSB9LCBjaGlsZHJlbik7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGFsdGVybmF0ZSByZXR1cm4gdHlwZXMgYXJlIG5vdCBwb3NzaWJsZSBkdWUgdG8gY29kZSB0cmFuc2Zvcm1hdGlvblxuICAgIFNlcnZlclN0eWxlU2hlZXQucHJvdG90eXBlLmludGVybGVhdmVXaXRoTm9kZVN0cmVhbSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5zZWFsZWQpIHtcbiAgICAgICAgICAgIHRocm93IHRocm93U3R5bGVkQ29tcG9uZW50c0Vycm9yKDIpO1xuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2VhbCgpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdsb2JhbC1yZXF1aXJlLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgICAgICAgICB2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtO1xuICAgICAgICAgICAgdmFyIHJlYWRhYmxlU3RyZWFtID0gaW5wdXQ7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBzaGVldF8xID0gX2EuaW5zdGFuY2UsIF9lbWl0U2hlZXRDU1NfMSA9IF9hLl9lbWl0U2hlZXRDU1M7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZXJfMSA9IG5ldyBUcmFuc2Zvcm0oe1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gYXBwZW5kU3R5bGVDaHVua3MoY2h1bmssIFxuICAgICAgICAgICAgICAgIC8qIGVuY29kaW5nICovXG4gICAgICAgICAgICAgICAgXywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjaHVuayBhbmQgcmV0cmlldmUgdGhlIHNoZWV0J3MgQ1NTIGFzIGFuIEhUTUwgY2h1bmssXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gcmVzZXQgaXRzIHJ1bGVzIHNvIHdlIGdldCBvbmx5IG5ldyBvbmVzIGZvciB0aGUgbmV4dCBjaHVua1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyZWRIdG1sID0gY2h1bmsudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBfZW1pdFNoZWV0Q1NTXzEoKTtcbiAgICAgICAgICAgICAgICAgICAgc2hlZXRfMS5jbGVhclRhZygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmVwZW5kIHN0eWxlIGh0bWwgdG8gY2h1bmssIHVubGVzcyB0aGUgc3RhcnQgb2YgdGhlIGNodW5rIGlzIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2luZyB0YWcgaW4gd2hpY2ggY2FzZSBhcHBlbmQgcmlnaHQgYWZ0ZXIgdGhhdFxuICAgICAgICAgICAgICAgICAgICBpZiAoQ0xPU0lOR19UQUdfUi50ZXN0KHJlbmRlcmVkSHRtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRPZkNsb3NpbmdUYWcgPSByZW5kZXJlZEh0bWwuaW5kZXhPZignPicpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZWZvcmUgPSByZW5kZXJlZEh0bWwuc2xpY2UoMCwgZW5kT2ZDbG9zaW5nVGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZnRlciA9IHJlbmRlcmVkSHRtbC5zbGljZShlbmRPZkNsb3NpbmdUYWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKGJlZm9yZSArIGh0bWwgKyBhZnRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2goaHRtbCArIHJlbmRlcmVkSHRtbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWFkYWJsZVN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yd2FyZCB0aGUgZXJyb3IgdG8gdGhlIHRyYW5zZm9ybSBzdHJlYW1cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lcl8xLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRhYmxlU3RyZWFtLnBpcGUodHJhbnNmb3JtZXJfMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTZXJ2ZXJTdHlsZVNoZWV0O1xufSgpKTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBfX1BSSVZBVEVfXyA9IHtcbiAgICBTdHlsZVNoZWV0OiBTdHlsZVNoZWV0LFxuICAgIG1haW5TaGVldDogbWFpblNoZWV0LFxufTtcblxuLyogSW1wb3J0IHNpbmdsZXRvbnMgKi9cbi8qIFdhcm5pbmcgaWYgeW91J3ZlIGltcG9ydGVkIHRoaXMgZmlsZSBvbiBSZWFjdCBOYXRpdmUgKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFwiSXQgbG9va3MgbGlrZSB5b3UndmUgaW1wb3J0ZWQgJ3N0eWxlZC1jb21wb25lbnRzJyBvbiBSZWFjdCBOYXRpdmUuXFxuXCIgK1xuICAgICAgICBcIlBlcmhhcHMgeW91J3JlIGxvb2tpbmcgdG8gaW1wb3J0ICdzdHlsZWQtY29tcG9uZW50cy9uYXRpdmUnP1xcblwiICtcbiAgICAgICAgJ1JlYWQgbW9yZSBhYm91dCB0aGlzIGF0IGh0dHBzOi8vd3d3LnN0eWxlZC1jb21wb25lbnRzLmNvbS9kb2NzL2Jhc2ljcyNyZWFjdC1uYXRpdmUnKTtcbn1cbi8qIFdhcm5pbmcgaWYgdGhlcmUgYXJlIHNldmVyYWwgaW5zdGFuY2VzIG9mIHN0eWxlZC1jb21wb25lbnRzICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICB0eXBlb2YgdW5kZWZpbmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgIHVuZGVmaW5lZFsnX19zdHlsZWQtY29tcG9uZW50cy1pbml0X18nXSB8fCAodW5kZWZpbmVkWydfX3N0eWxlZC1jb21wb25lbnRzLWluaXRfXyddID0gMCk7XG4gICAgaWYgKHVuZGVmaW5lZFsnX19zdHlsZWQtY29tcG9uZW50cy1pbml0X18nXSA9PT0gMSkgO1xuICAgIHVuZGVmaW5lZFsnX19zdHlsZWQtY29tcG9uZW50cy1pbml0X18nXSArPSAxO1xufVxuXG5leHBvcnRzLlNlcnZlclN0eWxlU2hlZXQgPSBTZXJ2ZXJTdHlsZVNoZWV0O1xuZXhwb3J0cy5TdHlsZVNoZWV0Q29uc3VtZXIgPSBTdHlsZVNoZWV0Q29uc3VtZXI7XG5leHBvcnRzLlN0eWxlU2hlZXRDb250ZXh0ID0gU3R5bGVTaGVldENvbnRleHQ7XG5leHBvcnRzLlN0eWxlU2hlZXRNYW5hZ2VyID0gU3R5bGVTaGVldE1hbmFnZXI7XG5leHBvcnRzLlRoZW1lQ29uc3VtZXIgPSBUaGVtZUNvbnN1bWVyO1xuZXhwb3J0cy5UaGVtZUNvbnRleHQgPSBUaGVtZUNvbnRleHQ7XG5leHBvcnRzLlRoZW1lUHJvdmlkZXIgPSBUaGVtZVByb3ZpZGVyO1xuZXhwb3J0cy5fX1BSSVZBVEVfXyA9IF9fUFJJVkFURV9fO1xuZXhwb3J0cy5jcmVhdGVHbG9iYWxTdHlsZSA9IGNyZWF0ZUdsb2JhbFN0eWxlO1xuZXhwb3J0cy5jc3MgPSBjc3M7XG5leHBvcnRzLmRlZmF1bHQgPSBzdHlsZWQ7XG5leHBvcnRzLmlzU3R5bGVkQ29tcG9uZW50ID0gaXNTdHlsZWRDb21wb25lbnQ7XG5leHBvcnRzLmtleWZyYW1lcyA9IGtleWZyYW1lcztcbmV4cG9ydHMuc3R5bGVkID0gc3R5bGVkO1xuZXhwb3J0cy51c2VUaGVtZSA9IHVzZVRoZW1lO1xuZXhwb3J0cy52ZXJzaW9uID0gU0NfVkVSU0lPTjtcbmV4cG9ydHMud2l0aFRoZW1lID0gd2l0aFRoZW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVkLWNvbXBvbmVudHMuY2pzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../styled-components/dist/styled-components.cjs.js\n");

/***/ }),

/***/ "@emotion/unitless":
/*!************************************!*\
  !*** external "@emotion/unitless" ***!
  \************************************/
/***/ ((module) => {

module.exports = require("@emotion/unitless");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

module.exports = require("react");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/***/ ((module) => {

module.exports = require("react/jsx-dev-runtime");

/***/ }),

/***/ "shallowequal":
/*!*******************************!*\
  !*** external "shallowequal" ***!
  \*******************************/
/***/ ((module) => {

module.exports = require("shallowequal");

/***/ }),

/***/ "stylis":
/*!*************************!*\
  !*** external "stylis" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stylis");

/***/ }),

/***/ "tslib":
/*!************************!*\
  !*** external "tslib" ***!
  \************************/
/***/ ((module) => {

module.exports = require("tslib");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("./pages/index.tsx"));
module.exports = __webpack_exports__;

})();